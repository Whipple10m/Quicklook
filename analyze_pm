# csh analyze1512d
# JHB 960115
# Script for automating quick-look analysis.
#
#h ANALYZE USAGE:
#h  
#h analyze [cmdlist] [option]
#h 
#h  [option]:
#h     batch    batch mode runs (no prompts)
#h     clean    remove unessential files created by analyze
#h     help     print out help on usage of the analyze script (this very text)
#h     pc       politically correct mode (delete files when done with them)
#h 
#h  [cmdlist]   name of file containing commands specifying nitrogen file(s)
#h              and ON/OFF files to be analyzed
#h  
#h     Possible commands (within the [cmdlist] file) are:
#h  
#h     n2 [n2file] [utdate]                                - for nitrogen run
#h  
#h     pr [onsourcefile] [offsourcefile] [n2id] [utdate]   - for ON/OFF data
#h  
#h     pr [onsourcefile] none [n2id] [utdate]              - for tracking data
#h  
#h        Note that [n2id] is given without leading 'gt00' or 'gt01'
#h   
#h    Additional optional commands :
#h  
#h    source [sourcename]   - Specify source name for plots
#h  
#h    newpath [searchpath]  - Specify an additional path (with trailing /) 
#h                            for raw data search
#h  
#h    analysis [class]  -  Options for [class] are:
#h         standard     -- standard supercuts analysis (default)
#h         littlelovers -- small events with length/size cut added to
#h                         standard shape and orientation cuts
#h         lowelevation -- low elevation cuts (from F. Krennrich, Padua
#h                         Workshop on TeV Gamma Ray Astronomy)
#h  
#h    flags [flagchars]   -  Change settings for parameterization;
#h                           [flagchars] is a sequence of characters
#h                           (any order) affecting gparamdat as follows:
#h         n  --  Produce a paw ntuple file of parameters
#h         a  --  Produce an old ascii format parameter file
#h         m  --  Perform a 2-dimensional mesh analysis
#h         f  --  Perform a 2-dimensional V.Fomin-like analysis (N/A)
#h         v  --  Perform a 2-d analysis with supercuts + vc,rcl dist cut
#h         u  --  Calculate parameters needed for uv analysis
#h         i  --  Run program in interactive mode; higz event display
#h         s  --  Use asymmetry parameter (costs some run time)
#h         l  --  Calculate muon ring parameters and pe/dc (slow!)
#h         x  --  Calculate position of most likely point of origin
#h         p  --  Show percent complete
#h         Default settings (as of July 2000): nvsx
#h                             
#h    RA [hhmmss.s]   - Manually specify RA and DEC of source 
#h    DEC [ddmmss.s]  
#h  
#h    XOFF [deg]      - Perform analysis with origin offset from center
#h    YOFF [deg]        by XOFF in RA, YOFF in DEC       
#h  
#h    trigger [num]   - [num] tubes in trigger, default=331 (only other
#h                      current option is 91) - really just changes which 
#h                      gparamdat is used
#h  
#h Example contents for [cmdlist] file:
#h    source Mrk421
#h    n2 gt000123 940911
#h    pr gt000124 gt000125 0123 940911 
#h    pr gt000126 gt000127 0123 940911 
#h    pr gt000128 none 0123 940911 
#h  

# All code to search for, decompress and recompress files was modified
# to accomodate bzip2 compression software. No additional comments are made
# about these changes in the body of the script. Also, the indentation has
# been fixed up (please indent by 2 spaces on ifs and whiles). SJF 990224

# The bzip2 compression seems to have slowed down the analysis greatly.
# So it has been changed backed to gzip. A new line has been added to 
# the transfer_10 script to search for all .gz files, uncompress them 
# and then bzip2 them. This way we save space using bzip2 but don't 
# waste time while running the analysis. SD 990609

set GZIP    = "/bin/gzip"                # set the paths to available
set GUNZIP  = "/bin/gzip -d"             # compression software here
set BZIP2   = "/usr/local/bin/bzip2"
set BUNZIP2 = "/usr/local/bin/bzip2 -d"
set TIDY_COMPRESS = $GZIP                # what we use to clean up

set batchmode = "false"

if(($2 == "batch")||($3 == "batch")) then
  set batchmode="true"
else
  set batchmode="false"
endif

if ($1:r == "zn" || $1:r == "ZN" || $1:r == "Zn") then
  echo '1' > zen.dat
else 
  echo '0' > zen.dat
endif


echo ' '
echo ' '
echo $0:t csh script:
echo ' '
if($?DISPLAY) then
  echo DISPLAY = $DISPLAY
else if($batchmode == "false") then
  echo Please enter DISPLAY:
  setenv DISPLAY $<
endif

# set path=(/home/local/whipple/prog $path)

# If the -clean argument is used, remove byproducts of analyze
#
if(($1 == "clean")||($2 == "clean")) then
  if(-e paths) /bin/rm -i paths
  if(-e dat.config) /bin/rm -i dat.config
  if(-e alphatot.kumac) /bin/rm -i alphatot.kumac
  if(-e quicklook.kumac) /bin/rm -i quicklook.kumac
  if(-e diagnostic.kumac) /bin/rm -i diagnostic.kumac
  if(-e last.kumac) /bin/rm -i last.kumac
  if(-e last.kumacold) /bin/rm -i last.kumacold
  if(-e last.ql) /bin/rm -i last.ql
  if(-e last.qlold) /bin/rm -i last.qlold
  if(-e qlrun.kumac) /bin/rm -i qlrun.kumac
  if(-e fort.3) /bin/rm -i fort.3
  if(-e fort.7) /bin/rm -i fort.7
  if(-e paw.metafile) /bin/rm -i paw.metafile
  if(-e pairs) /bin/rm -i pairs
# if(-e pawpairs) /bin/rm -i pawpairs
  if(-e pawon.kumac) /bin/rm -i pawon.kumac
  if(-e pawoff.kumac) /bin/rm -i pawoff.kumac
  if(-e temp) /bin/rm -i temp
  if(-e hrc.pairlist) /bin/rm -i hrc.pairlist
  if(-e zen.dat) /bin/rm -i zen.dat
  echo "compress *.rz (y/n)?"
  set answer = $<
  if(($answer == "y")||($answer == "Y")) then
    ls *.rz >>& /dev/null
    if($status == 0) then
      echo Compressing .rz files
      $TIDY_COMPRESS *.rz
    endif
  endif
  ls *.pdat >>& /dev/null
  if($status == 0) then
    /bin/rm -i *.pdat
  endif
  ls gt???? >>& /dev/null
  if($status == 0) then
    /bin/rm -i gt????
  endif
  ls gt*.fz >>& /dev/null
  if($status == 0) then
    /bin/rm -i gt*.fz
  endif
  exit
endif 

# Extract comment lines starting with #h for help
# 
if(($1 == "")||($1 == "help")||($1 == "man")||($2 == "help")) then
  awk '$1 == "#h" {print }' $0 > temp1234     # Get lines starting with #h
  sed "s/\#h //g" < temp1234  | more          # Delete these chars
  /bin/rm temp1234
  exit
endif

# Extract the file dat.config needed by gparamdat, cutdat and tabdat
#
if(-e dat.config) then  # if file exists
  echo Using dat.config in local directory
else                    # if not, extract from end of this script
  echo Extracting default "dat.config" from the $0:t script
  awk '$1 == "#!" {print }' $0 > temp1234     # Get lines starting with #! 
  sed "s/\#\! //g" < temp1234  > dat.config   # Delete these chars
  /bin/rm temp1234
endif

if(($2 == "pc")||($3 == "pc")) then     
  set pcflag = "true"
else
  set pcflag = "false"
endif

# See if there are command "flags" to change the default
# parameterize flags
#
# set pdatcontrol = "vunxs"
set pdatcontrol = "vnxs"
set temp = `cat $1 | awk '$1 == "flags" {print $2}'`
cat $1 | grep flags >& /dev/null
if($status == 0) then
  set pdatcontrol = $temp[1]
  echo Changing default gparamdat flags: $pdatcontrol
else
  echo Using default gparamdat flags: $pdatcontrol
endif

# Added by JB 951031 - to specify ra and dec
#
set racmd = ""
set deccmd = ""
set temp = `cat $1 | awk '$1 == "RA" {print $2}'`
cat $1 | grep RA >& /dev/null
if($status == 0) then
  set racmd = $temp[1]
  set fra = "true"
endif
set temp = `cat $1 | awk '$1 == "DEC" {print $2}'`
cat $1 | grep DEC >& /dev/null
if($status == 0) then
  set deccmd = $temp[1]
  echo setting RA to $racmd
  echo setting DEC to $deccmd
  if($fra == "true") then
    set pdatcontrol = `echo c$pdatcontrol $racmd $deccmd`
    echo Changing gparamdat arguments to: $pdatcontrol
  endif
endif

# Added by JB 991207 - to specify xoff and yoff
#
set temp = `cat $1 | awk '$1 == "XOFF" {print $2}'`
cat $1 | grep XOFF >& /dev/null
if($status == 0) then
  set xoffcmd = $temp[1]
  set fxoff = "true"
endif
set temp = `cat $1 | awk '$1 == "YOFF" {print $2}'`
cat $1 | grep YOFF >& /dev/null
if($status == 0) then
  set yoffcmd = $temp[1]
  echo setting XOFF to $xoffcmd
  echo setting YOFF to $yoffcmd
  if($fxoff == "true") then
    set pdatcontrol = `echo o$pdatcontrol $xoffcmd $yoffcmd`
    echo Changing gparamdat arguments to: $pdatcontrol
  endif
endif

# See if a source name for plot titles has been specified
#
set sourcename = `cat $1 | awk '$1 == "source" {print $2 $3}'`
if($sourcename != "") then
  echo Sourcename set to $sourcename
else
  echo Sourcename not specified
  set sourcename = "x"
endif

# See if small events should be analyzed instead of the standard analysis.
#
set analysis = `cat $1 | awk '$1 == "analysis" {print $2}'`
if ($analysis != "") then
  echo "********************************************************"
  echo Proceeding with the $analysis analysis
  echo "********************************************************"
else
  echo "********************************************************"
  echo Proceeding with the standard analysis
  echo "********************************************************"
  set analysis = "standard"
endif

# See if trigger other than 331 was used in the data.
#
set trigger = `cat $1 | awk '$1 == "trigger" {print $2}'`
if ($trigger == "91") then
  echo "********************************************************"
  echo 91 Tubes will be used in the trigger
  echo "********************************************************"
else
  echo "********************************************************"
  echo 331 Tubes will be used in the trigger
  echo "********************************************************"
endif

# if(($2 != "pc")&&($2 != "clean")&&($2 != "help")&&($2 != "")) then    
#   set pdatcontrol = $2
# else
#   set pdatcontrol = "munxls"
# endif

# Extract the file paths needed by fz2red
#
if(-e paths) then       # if file exists
  echo Using the file paths in local directory
else                    # if not, extract from end of this script
  echo Extracting default file "paths" from the $0:t script
  awk '$1 == "#p" {print }' $0 > temp1234     # Get lines starting with #p
  sed "s/\#p //g" < temp1234  > paths         # Delete these chars
  /bin/rm temp1234
endif

# Extract file alphatot.kumac used to make combined alpha plots in paw
#
if(-e alphatot.kumac) then
  echo Using "alphatot.kumac" in local directory
else            
  echo Extracting default alphatot.kumac from the $0:t script
  awk '$1 == "#pal" {print }' $0 > temp1234 
  sed "s/\#pal //g" < temp1234  > temp1235
  /bin/rm temp1234
  if(($analysis == "") || ($analysis == "standard")) then
    sed "s/\*std //g" < temp1235 > alphatot.kumac
  else if($analysis == "1998") then
    sed "s/\*st98 //g" < temp1235 > alphatot.kumac
  else if($analysis == "1997") then
    sed "s/\*st97 //g" < temp1235 > alphatot.kumac
  else if($analysis == "littlelovers") then
    sed "s/\*ltl //g" < temp1235 > alphatot.kumac
  else if($analysis == "lowelevation") then
    sed "s/\*lel //g" < temp1235 > alphatot.kumac
  else 
    echo Analysis type $analysis unknown, using standard cuts
    sed "s/\*std //g" < temp1235 > alphatot.kumac
    set analysis = "standard"
  endif
  /bin/rm temp1235
endif

# Extract the file quicklook.kumac used to create paw plots from
# the gparamdat ntuples
#
if(-e quicklook.kumac) then
  echo Using quicklook.kumac in local directory
else            
  echo Extracting default "quicklook.kumac" from the $0:t script
  awk '$1 == "#pql" {print }' $0 > temp1234          # Lines starting #pql
  sed "s/\#pql //g" < temp1234  > quicklook.kumac    # Delete these chars   
  /bin/rm temp1234
endif
 
# Extract the file diagnostic.kumac used to create paw plots from
# fz2red histogram file gtnnnn_d.hbook
#
if(-e diagnostic.kumac) then
  echo Using diagnostic.kumac in local directory
else            
  echo Extracting default "diagnostic.kumac" from the $0:t script
  awk '$1 == "#pdg" {print }' $0 > temp1234          # Lines starting #pdg
  sed "s/\#pdg //g" < temp1234  > diagnostic.kumac   # Delete these chars   
  /bin/rm temp1234
endif

# Need to create pairs file for tabdat
#
if(-e pairs) then
  echo pairs file already exists - deleting old file, creating new one.
  /bin/rm pairs
# echo "Delete it and continue with analysis (y/n)?"
# set answer = $<
# if(($answer == "y")||($answer == "Y")) then
#   /bin/rm pairs
# else
#   echo Exiting $0:t
#   exit
# endif
endif

if(-e pawoff.kumac) then
  echo The file pawoff.kumac already exists.  Deleting the old file
  echo and creating a new one.
  /bin/rm pawoff.kumac
endif
if(-e pawon.kumac) then
  echo The file pawon.kumac already exists.  Deleting the old file
  echo and creating a new one.
  /bin/rm pawon.kumac
endif
echo "inon = 0" >> pawon.kumac
echo "inoff = 0" >> pawoff.kumac
if(-e last.ql) then
  /bin/mv last.ql last.qlold
endif 
  
set qlrun = "qlrun.kumac"
if(-e qlrun.kumac) then
  echo "The file qlrun.kumac (created to control PAW analysis) already"
  echo "exists.  Deleting it and continuing with the analysis."
  /bin/rm qlrun.kumac
# echo The file qlrun.kumac is created by this script to control
# echo the PAW analysis of the ntuples.  This file already exists.
# echo "Delete it and continue (y/n)?"
# set answer = $<
# if(($answer == "y")||($answer == "Y")) then
#   /bin/rm qlrun.kumac
# else
#   echo Please enter a new name for a .kumac run file
#   unset qlrun
#   set qlrun = $<
# endif
endif

set newpath = `cat $1 | awk '$1 == "newpath" {print $2}'`

set n2list = `cat $1 | awk '$1 == "n2" {print $2, $3}'`
set prlist = `cat $1 | awk '$1 == "pr" {print $2, $3, $4, $5}'`
set stlist = `echo st nd rd th`

# JQ 980724
set pathlist = `echo ./ $newpath /draco/raw10/ /eltanin/raw10/`
echo Data search paths: $pathlist
set statuslist = `echo good bad`
set found = "false"
set foundon = "false"
set foundoff = "false"

# echo Nitrogen command list
# echo $n2list
# echo Pair command list
# echo $prlist

@ i = 1
@ j = 2
@ k = 1

# Begin Nitrogen file analysis
#
while($i < $#n2list)            # For each nitrogen file
  if($k < $#stlist) then        # Just print a fancy message
    echo Analyzing the {$k}$stlist[$k] nitrogen file
  else
    echo Analyzing the {$k}th nitrogen file
  endif

  set found = "false"
  set compressed = "false"

  @ n = 1                       # Now begin searching for the n2 file
  unset fullname
  set fullname = ""
  set pathnum = $n
  while (($fullname == "") && ($n <= $#pathlist))
    unset fullname              # Look in the paths in pathlist
    set fullname = `find $pathlist[$n] -name $n2list[$i].fz -print` 
    set pathnum = $n
    @ n++
  end
  if($fullname != "") then
    set found = "true"
    set compressed = "false"
  endif

  if($found == "false") then    # A null name means nothing found
    @ n = 1                     # so look for a compressed file
    unset fullname
    set fullname = ""
    set pathnum = $n
    while (($fullname == "") && ($n <= $#pathlist))
      unset fullname            # Look in the paths in pathlist
      set fullname = `find $pathlist[$n] -name $n2list[$i].fz.bz2 -print` 
      set pathnum = $n
      @ n++
    end
    if($fullname != "") then
      set found = "true"
      set compressed = "bzip2"
    endif
  endif
        
  if($found == "false") then    # A null name means nothing found
    @ n = 1                     # so look for a compressed file
    unset fullname
    set fullname = ""
    set pathnum = $n
    while (($fullname == "") && ($n <= $#pathlist))
      unset fullname            # Look in the paths in pathlist
      set fullname = `find $pathlist[$n] -name $n2list[$i].fz.gz -print` 
      set pathnum = $n
      @ n++
    end
    if($fullname != "") then
      set found = "true"
      set compressed = "gzip"
    endif
  endif

  if($found == "false") then    # A null name means nothing found
    @ n = 1                     # so look for a compressed file
    unset fullname
    set fullname = ""
    set pathnum = $n
    while (($fullname == "") && ($n <= $#pathlist))
      unset fullname            # Look in the paths in pathlist
      set fullname = `find $pathlist[$n] -name $n2list[$i].fz.Z -print` 
      set pathnum = $n
      @ n++
    end
    if($fullname != "") then
      set found = "true"
      set compressed = "gzip"
    endif
  endif

  if($found == "false") then
    echo Could not find the file $n2list[$i].fz or $n2list[$i].fz.gz
    echo skipping this one and continuing with the analysis...
  endif

  if($found == "true") then     # If the n2 file was found, copy it to the
    if($pathnum != 1) then      
      cp $fullname .            # current directory
      echo copy $fullname to $fullname:t
    endif
    set fullname = $fullname:t  # Reset fullname to give the name of the file
                                # with the path stripped away
  endif

  if (($found == "true")&&($compressed != "false")) then
    if($compressed == "bzip2") then
      $BUNZIP2 $fullname          # uncompress the file in the local directory
      set fullname = $fullname:r  # and strip the .bz2 extension,reset fullname
      echo uncompressed file: $fullname
    endif
    if($compressed == "gzip") then
      $GUNZIP $fullname           # uncompress the file in the local directory
      set fullname = $fullname:r  # and strip the .gz extension, reset fullname
      echo uncompressed file: $fullname
    endif
  endif

  set laststatus = 0            # Initialize status variable to good
  if ($found == "true") then    # If there is a nitrogen file, strip out
                                # two lsd of run number for compat. with old
                                # analysis routines.
    set abbrname = \
`echo $n2list[$i] | sed "s/gt0./gt/" | sed "s/ge00/ge/" `
#mac`echo $n2list[$i] | sed "s/gt00/gt/" | sed "s/ge00/ge/" | sed "s/gs00/gs/"`
    set runid = \
`echo $n2list[$i] | sed "s/gt0.//" | sed "s/ge00//"`
#mac`echo $n2list[$i] | sed "s/gt00//" | sed "s/ge00//" | sed "s/gs00//"`
    if(-e $abbrname) then       # If output of fz2red already exists
                                # then don't repeat this step
      echo $abbrname already exists, skipping fz2red
      set laststatus = 0
    else
      if(-e $abbrname.bz2) then
        echo $BUNZIP2 $abbrname.bz2
        $BUNZIP2 $abbrname.bz2
        echo $abbrname already exists, skipping fz2red
        set laststatus = 0
      else if(-e $abbrname.gz) then
        echo $GUNZIP $abbrname.gz
        $GUNZIP $abbrname.gz
        echo $abbrname already exists, skipping fz2red
        set laststatus = 0
      else
        echo fz2red $fullname $n2list[$j] >> last.ql    # Log it
        echo fz2red $fullname $n2list[$j]               # Echo it
        fz2red $fullname $n2list[$j]    # Convert from zebra to old format
        set laststatus = $status        # Store exit status of fz2red
      endif
    endif
#   echo $abbrname
    if($laststatus == 0) then   # If the last command worked, keep going
      if($pcflag == "true") then
#       echo 'here'
	echo ' '
        echo "Warning: removing ./"$fullname
        /bin/rm ./$fullname
	echo ' '
      else
        $TIDY_COMPRESS ./$fullname      # FORCED SPACE CONSERVATION
      endif
      echo gcpeds $abbrname >> last.ql  # Log it, Echo it
      echo gcpeds $abbrname     # No harm in repeating, since gcodepeds
                                # first determines if entry for this run
                                # already exists...
      gcpeds $abbrname          # Generate injected peds in database
      if($status == 0) then     # if gcodepeds worked, keep going...
                                # Look for header line for run in db
#MAC 970805 took the following line out
#MAC    grep "$n2list[$j] N2 $runid" /home/db*/*.n2gains > /dev/null
#MAC    if($status == 1) then   # No entry exists in the database
        echo gn2gains $abbrname >> last.ql
        echo gn2gains $abbrname 
        gn2gains $abbrname      
#MAC    else
#MAC      echo "NG ** An entry for $n2list[$j], run $runid alread exists"
#MAC      echo "NG ** in the database, skipping gn2gains."
#MAC    endif
        if($pcflag == "true") then
          echo "Warning: removing ./"$abbrname
          /bin/rm ./$abbrname
        else
          $TIDY_COMPRESS ./$abbrname    # FORCED SPACE CONSERVATION
        endif
      else
        echo Bad status from gcpeds, skipping gn2gains $n2list[$j]
      endif
    endif
  endif
  @ i+=2
  @ j+=2
  @ k++
end

#
# Begin the analysis of the on/off or tracking data
#
echo 1.$DISPLAY > $qlrun                # Write some header info to the
# echo "exec pawsys.kumac" >> $qlrun    # paw control script $qlrun

@ ion = 1               # ON file
@ ioff = 2
@ initro = 3
@ idate = 4
@ k = 1

while($ion < $#prlist)

  if($k < $#stlist) then        # Print fancy message
    echo Analyzing the {$k}$stlist[$k] pair
  else
    echo Analyzing the {$k}th pair
  endif
                                
  if($prlist[$ioff] == "none") then
    echo Pair file name $prlist[$ioff] --> tracking data
    set trackmode = "track"
  else
    echo Pair file name $prlist[$ioff] --> ON/OFF data
    set trackmode = "onoff"
#   @ n = 1                     
  endif

#
# First generate the name of the .rz file which will be the end product of
# the analysis for this pair.  If the .rz or .rz.gz files exist, simply 
# uncompress the files if necessary, generate the appropriate entries in
# the pairs file, redo the paw analysis and skip the rest for this pair.
#
  set aonname = \
`echo $prlist[$ion] | sed "s/gt0./gt/" | sed "s/ge00/ge/"`
#mac `echo $prlist[$ion] | sed "s/gt00/gt/" | sed "s/ge00/ge/" | sed "s/gs00/gs/"`
  if($ion == 1) then
    set firston = $aonname
  endif
  if($trackmode == "onoff") then
    set aoffname = \
`echo $prlist[$ioff] | sed "s/gt0./gt/" | sed "s/ge00/ge/"`
#mac `echo $prlist[$ioff] | sed "s/gt00/gt/" | sed "s/ge00/ge/" | sed "s/gs00/gs/"`
  else
    set aoffname = "none"
  endif
  if(-e $aonname.rz.bz2) then
    echo $BUNZIP2 $aonname.rz.bz2
    $BUNZIP2 $aonname.rz.bz2
  else if(-e $aonname.rz.gz) then
    echo $GUNZIP $aonname.rz.gz
    $GUNZIP $aonname.rz.gz
  endif
  if(($trackmode == "onoff")&&(-e $aoffname.rz.bz2)) then
    echo $BUNZIP2 $aoffname.rz.bz2
    $BUNZIP2 $aoffname.rz.bz2
  else if(($trackmode == "onoff")&&(-e $aoffname.rz.gz)) then
    echo $GUNZIP $aoffname.rz.gz
    $GUNZIP $aoffname.rz.gz
  endif
                                # If this is on/off and both .rz files
                                # exist, redo all paw commands
  if(($trackmode == "onoff")&&(-e $aonname.rz)&&(-e $aoffname.rz)) then
    echo The pair of files $aonname.rz and $aoffname.rz already exist.
    echo Skipping fz2red, codepeds, and gparamdat for this pair.
    if((-e $aonname"_ql".ps)||(-e $aonname"_ql".ps.gz)) then
      echo $aonname"_ql".ps already exists, skipping quicklook.kumac
    else
      echo exec quicklook $aonname >> $qlrun
    endif
    if((-e $aoffname"_ql".ps)||(-e $aoffname"_ql".ps.gz)) then
      echo $aoffname"_ql".ps already exists, skipping quicklook.kumac
    else
      echo exec quicklook $aoffname >> $qlrun
    endif
    if((-e $aonname"_dg".ps)||(-e $aonname"_dg".ps.gz)) then
      echo $aonname"_dg".ps already exists, skipping diagnostic.kumac
    else
      if((-e $aonname"_d".hbook)||(-e $aonname"_d".hbook.gz)) then
        echo exec diagnostic $aonname >> $qlrun
      else
        echo $aonname"_d".hbook does not exist, skipping diagnostic.kumac
      endif
    endif
    if((-e $aoffname"_dg".ps)||(-e $aoffname"_dg".ps.gz)) then
      echo $aoffname"_dg".ps already exists, skipping diagnostic.kumac
    else
      if((-e $aoffname"_d".hbook)||(-e $aoffname"_d".hbook.gz)) then
        echo exec diagnostic $aoffname >> $qlrun
      else
        echo $aoffname"_d".hbook does not exist, skipping diagnostic.kumac
      endif
    endif
    echo exec alphatot $sourcename 1 $aonname $aoffname >> $qlrun
                                # Otherwise, if this is a tracking run
                                # and the .rz file exists, at least redo
                                # paw stuff, but skip the rest.
    echo $aonname $aoffname >> pairs
    echo CHAIN allon $aonname.rz >> pawon.kumac
    echo CHAIN allof $aoffname.rz >> pawoff.kumac
    echo "inon = [inon] + 1" >> pawon.kumac
    echo "inoff = [inoff] + 1" >> pawoff.kumac
#   echo $aonname $aoffname >> pawpairs
    echo $aonname $aoffname >> hrc.pairlist
  else if(($trackmode == "track")&&(-e $aonname.rz)) then
    echo The traking data file $aonname.rz already exists.
    echo Skipping fz2red, codepeds, and gparamdat for this file.
    if((-e $aonname"_ql".ps)||(-e $aonname"_ql".ps.gz)) then
      echo $aonname"_ql".ps already exists, skipping quicklook.ql
    else
      echo exec quicklook $aonname >> $qlrun
    endif
    if((-e $aonname"_dg".ps)||(-e $aonname"_dg".ps.gz)) then
      echo $aonname"_dg".ps already exists, skipping diagnostic.kumac
    else
      if((-e $aonname"_d".hbook)||(-e $aonname"_d".hbook.gz)) then
        echo exec diagnostic $aonname >> $qlrun
      else
        echo $aonname"_d".hbook does not exist, skipping diagnostic.kumac
      endif
    endif
    echo exec alphatot $sourcename 1 $aonname none >> $qlrun
    echo CHAIN allon $aonname.rz >> pawon.kumac
    echo "inon = [inon] + 1" >> pawon.kumac
#   echo $aonname none >> pawpairs
    echo $aonname $aonname >> hrc.pairlist      # This is a patch to let
                        # paramdat do it's thing
                        # for tracking data when padding
                        # is on.
  else                          # If no .rz files, then start the first step
                                # of the analysis, but check at each step 
                                # whether you are duplicating previous work
                                # Mod. JB 950707 - Redo parameterization
                                # step regardless of the existence of .rz
                                # files to make sure on/off get padded
                                # properly
#
# First search for files in old data format, in the local directory
# (old data format with the source id "gt","ge", or "gs" that is.)
#
    set foundon = "false"
    set foundoff = "false"
    set copyon = "false"        # Flags for indicating that the files were
    set copyoff = "false"       # copied in from another dir.
     
    echo $aonname.rz not found, now search for reduced format file: $aonname
    set fonname = "none1234"
    set foffname = "none1234"
    set aonname = \
`echo $prlist[$ion] | sed "s/gt0./gt/" | sed "s/ge00/ge/"`
#mac `echo $prlist[$ion] | sed "s/gt00/gt/" | sed "s/ge00/ge/" | sed "s/gs00/gs/"`
    set aoffname = \
`echo $prlist[$ioff] | sed "s/gt0./gt/" | sed "s/ge00/ge/"`
#mac `echo $prlist[$ioff] | sed "s/gt00/gt/" | sed "s/ge00/ge/" | sed "s/gs00/gs/"`
    if(-e $aonname) then
      set foundon = "true"
    else if(-e $aonname.bz2) then       # Added by SJF 990224
      echo $BUNZIP2 $aonname.bz2
      $BUNZIP2 $aonname.bz2
      set foundon = "true"
    else if(-e $aonname.gz) then        # Added by JB 950811 
      echo $GUNZIP $aonname.gz
      $GUNZIP $aonname.gz
      set foundon = "true"
    endif
    if(-e $aoffname) then
      set foundoff = "true"
    else if(-e $aoffname.bz2) then      # Added by SJF 990224
      echo $BUNZIP $aoffname.bz2
      $BUNZIP $aoffname.bz2
      set foundoff = "true"
    else if(-e $aoffname.gz) then       # Added by JN 950811
      echo $GUNZIP $aoffname.gz
      $GUNZIP $aoffname.gz
      set foundoff = "true"
    endif
#   if($foundon == "false") then
#     echo Could not find the file $prlist[$ion].fz or $prlist[$ion].fz.gz,
#     echo or $aonname, skipping this pair and continuing with
#     echo the analysis...
#   endif
#
# Search for the ON-file
#
    if($foundon == "false") then
      echo Could not locate ${aonname}, $aonname.bz2 or $aonname.gz, looking for 
      echo $prlist[$ion].fz, $prlist[$ion].fz.bz2, $prlist[$ion].fz.gz or $prlist[$ion].fz.Z instead...
      set compressed = "false"

      @ n = 1                   
      set fonname = ""
      set pathnum = $n

      while (($fonname == "") && ($n <= $#pathlist))
        unset fonname           # Look in the paths in pathlist
        set fonname = `find $pathlist[$n] -name $prlist[$ion].fz -print` 
        set pathnum = $n
        @ n++
      end
      if($fonname != "") then
        set compressed = "false"
        set foundon = "true"
      endif

      if($foundon == "false") then
        @ n = 1                 
        set fonname = ""
        set pathnum = $n
        while (($fonname == "") && ($n <= $#pathlist))
          unset fonname         # Look in the paths in pathlist
          set fonname = `find $pathlist[$n] -name $prlist[$ion].fz.bz2 -print`
          set pathnum = $n
          @ n++
        end
        if($fonname != "") then
          set compressed = "bzip2"
          set foundon = "true"
        endif
      endif

      if($foundon == "false") then
        @ n = 1                 
        set fonname = ""
        set pathnum = $n

        while (($fonname == "") && ($n <= $#pathlist))
          unset fonname         # Look in the paths in pathlist
          set fonname = `find $pathlist[$n] -name $prlist[$ion].fz.gz -print` 
          set pathnum = $n
          @ n++ 
	end

        if($fonname != "") then
          set compressed = "gzip"
          set foundon = "true"
        endif
      endif

      if($foundon == "false") then
        @ n = 1                     
        set fonname = ""
        set pathnum = $n
        while (($fonname == "") && ($n <= $#pathlist))
          unset fonname             # Look in the paths in pathlist
          set fonname = `find $pathlist[$n] -name $prlist[$ion].fz.Z -print` 
          set pathnum = $n
          @ n++
        end
        if($fonname != "") then
          set compressed = "gzip"
          set foundon = "true"
        endif
      endif

      if($foundon == "true") then  # If found on file, copy it to local dir
        if($pathnum != 1) then
          cp $fonname .
          echo copied $fonname to $fonname:t
          set copyon = "true"
        endif
        set fonname = $fonname:t    # and remove the path from the name
      endif
      if(($foundon == "true") && ($compressed != "false")) then
        if($compressed == "bzip2") then
          echo $BUNZIP2 $fonname
          $BUNZIP2 $fonname         # If compressed uncompress and
        else if($compressed == "gzip") then
          echo $GUNZIP $fonname
          $GUNZIP $fonname          # If compressed uncompress and
        endif
        set fonname = $fonname:r    # strip out .gz extension
#       echo uncompressed filename: $fonname
      endif
    endif

#
# Now search for the OFF-file
#
    set compressed = "false"
    set foffname = "none"

    if($foundoff == "false") then
      if($trackmode == "onoff") then
        echo Could not locate $aoffname, $aoffname.bz2 or $aoffname.gz, looking for 
        echo $prlist[$ioff].fz, $prlist[$ioff].fz.bz2, $prlist[$ioff].fz.gz, or $prlist[$ioff].fz.Z instead...
        @ n = 1
        set foffname = ""
        set pathnum = $n
        while (($foffname == "") && ($n <= $#pathlist))
          unset foffname            # Look in the paths in pathlist
          set foffname = `find $pathlist[$n] -name $prlist[$ioff].fz -print` 
          set pathnum = $n
          @ n++
        end
        if($foffname != "") then
          set compressed = "false"
          set foundoff = "true"
        endif

        if($foundoff == "false") then # Try again, this time with .gz extension
          @ n = 1                   
          set foffname = ""
          set pathnum = $n
          while (($foffname == "") && ($n <= $#pathlist))
            unset foffname          # Look in the paths in pathlist
            set foffname = `find $pathlist[$n] -name $prlist[$ioff].fz.bz2 -print` 
            set pathnum = $n
            @ n++
          end
          if($foffname != "") then
            set compressed = "bzip2"
            set foundoff = "true"
          endif
        endif

        if($foundoff == "false") then # Try again, this time with .gz extension
          @ n = 1                   
          set foffname = ""
          set pathnum = $n
          while (($foffname == "") && ($n <= $#pathlist))
            unset foffname          # Look in the paths in pathlist
            set foffname = `find $pathlist[$n] -name $prlist[$ioff].fz.gz -print` 
            set pathnum = $n
            @ n++
          end
          if($foffname != "") then
            set compressed = "gzip"
            set foundoff = "true"
          endif
        endif

        if($foundoff == "false") then # Try again, this time with .gz extension
          @ n = 1                   
          set foffname = ""
          set pathnum = $n
          while (($foffname == "") && ($n <= $#pathlist))
            unset foffname          # Look in the paths in pathlist
            set foffname = `find $pathlist[$n] -name $prlist[$ioff].fz.Z -print` 
            set pathnum = $n
            @ n++
          end
          if($foffname != "") then
            set compressed = "gzip"
            set foundoff = "true"
          endif
        endif

        if($foundoff == "true") then
          if($pathnum != 1) then            # Path 1 means the local directory
            cp $foffname .
            echo copied $foffname to $foffname:t
            set copyoff = "true"
          endif
          set foffname = $foffname:t        # and remove the path from the name
        endif
        if(($foundoff == "true")&&($compressed != "false")) then
          if($compressed == "bzip2") then
            echo $BUNZIP2 $foffname
            $BUNZIP2 $foffname              # If compressed uncompress and
          else if($compressed == "gzip") then
            echo $GUNZIP $foffname
            $GUNZIP $foffname              # If compressed uncompress and
          endif
          set foffname = $foffname:r        # strip out .gz extension
#         echo uncompressed filename: $foffname
        endif 
      endif # end if trackmode = "onoff"

    endif # edn if foundoff = false

    if($foundon == "true") then  # Only continue with the analysis if at least
                                # the on file was found, but if this is on/off
                                # and no off file is found...
      if(($foundoff == "false")&&($trackmode == "onoff")) then 
        echo Could not find the file $prlist[$ioff].fz, 
        echo skipping this pair and continuing with the analysis...
      else                        # Otherwise this is either tracking mode
                                # or on/off with off data so continue...
                                # First strip out 2 lsd for compatibility
        set aoffname = "none"
        set aonname = \
`echo $prlist[$ion] | sed "s/gt0./gt/" | sed "s/ge00/ge/"`
#mac `echo $prlist[$ion] | sed "s/gt00/gt/" | sed "s/ge00/ge/" | sed "s/gs00/gs/"`
        if($trackmode == "onoff") then
          set aoffname = \
`echo $prlist[$ioff] | sed "s/gt0./gt/" | sed "s/ge00/ge/"`
#mac `echo $prlist[$ioff] | sed "s/gt00/gt/" | sed "s/ge00/ge/" | sed "s/gs00/gs/"`
        endif

        if($trackmode == "onoff") then     # If this is an on/off pair, add it to
                                # pairs hrc.pairlist file for gparamdat
                                # This file is used for padding and to 
                                # match turned-off tubes
          echo $aonname $aoffname >> hrc.pairlist
        else if($trackmode == "track") then        # This is a patch to make
                                # tracking data work with padding on -- just
                                # a safe thing to do for quick look analysis
          echo $aonname $aonname >> hrc.pairlist
        endif
#
# Modified by JB 950706
#       if((-e $aonname)||(-e $aonname.rz)||(-e $aonname.rz.gz)) then      
        if(-e $aonname) then       
                                # If output of fz2red 
                                # already exists, then don't repeat this step
          echo $aonname" already exists, skipping fz2red"
#         echo $aonname" (or .rz) already exists, skipping fz2red"
          set statusfzon = 0
        else
          if(-e $aonname.bz2) then
            echo $BUNZIP2 $aonname.bz2
            $BUNZIP2 $aonname.bz2
            echo $aonname" already exists, skipping fz2red"
            set statusfzon = 0
          else if(-e $aonname.gz) then
            echo $GUNZIP $aonname.gz
            $GUNZIP $aonname.gz
            echo $aonname" already exists, skipping fz2red"
            set statusfzon = 0
          else
            echo fz2red $fonname $prlist[$idate] >> last.ql # Log it
            echo fz2red $fonname $prlist[$idate]                    # Echo it
            fz2red $fonname $prlist[$idate] # Convert from zebra to old format
            set statusfzon = $status        # Record status of fz2red
          endif
        endif
        set statusfzoff = 0
        if($trackmode == "onoff") then
#
# Modified by JB 950706
#         if((-e $aoffname)||(-e $aoffname.rz)||(-e $aoffname.rz.gz)) then
          if(-e $aoffname) then
                                # If output of fz2red or param file 
                                # already exists then don't repeat this step
            echo $aoffname" already exists, skipping fz2red"
#           echo $aoffname" (or .rz) already exists, skipping fz2red"
            set statusfzoff = 0
          else
            if(-e $aoffname.bz2) then
              echo $BUNZIP2 $aoffname.bz2
              $BUNZIP2 $aoffname.bz2
              echo $aoffname" already exists, skipping fz2red"
              echo $aoffname" (or .rz) already exists, skipping fz2red"
              set statusfzoff = 0
            else if(-e $aoffname.gz) then
              echo gunzip $aoffname.gz
              gunzip $aoffname.gz
              echo $aoffname" already exists, skipping fz2red"
              echo $aoffname" (or .rz) already exists, skipping fz2red"
              set statusfzoff = 0
            else
              echo fz2red $foffname $prlist[$idate] >> last.ql      # Log it
              echo fz2red $foffname $prlist[$idate]                 # Echo it
              fz2red $foffname $prlist[$idate]  # Convert from zebra to old format
              set statusfzoff = $status
            endif
          endif
        endif

        if($statusfzon == 0) then  # if status is good continue
          if($pcflag == "true") then
            if($copyon == "true") then      # Only delete if this file was
                                        # copied from somewhere else!
              echo "Warning: removing ./"$fonname
              /bin/rm ./$fonname
            else
              if(-e ./$fonname) then
                $TIDY_COMPRESS ./$fonname           # FORCED SPACE CONSERVATION
              endif
            endif
          else
            if(-e ./$fonname) then
              $TIDY_COMPRESS ./$fonname             # FORCED SPACE CONSERVATION
            endif
          endif # pcflag
          if(-e $aonname) then
            echo gcpeds $aonname >> last.ql
            echo gcpeds $aonname
            gcpeds $aonname
            set statuscpon = $status
          else
            set statuscpon = 0
            echo "Warning: "$aonname" not found, skipping gcpeds"
          endif
          set statuscpoff = 0
          if($trackmode == "onoff") then
            if($statusfzoff == 0) then      # If fz2red completed successfully,
                                          # then run codepeds...
              if($pcflag == "true") then
                if($copyoff == "true") then
                  echo "Warning: removing ./"$foffname
                  /bin/rm ./$foffname
                else
                  if(-e ./$foffname) then
                    $TIDY_COMPRESS ./$foffname
                  endif
                endif
              else
                if(-e ./$foffname) then
                  $TIDY_COMPRESS ./$foffname                # FORCED SPACE CONSERVATION
                endif
              endif
              if(-e $aoffname) then
                echo gcpeds $aoffname >> last.ql    # Log it
                echo gcpeds $aoffname               # echo it
                gcpeds $aoffname
                set statuscpoff = $status
              else
                set statuscpoff = 0
                echo "Warning: "$aoffname" not found, skipping gcpeds"
              endif
            endif
          endif
#
# Commented-out by JB 950706
#         if(-e $aonname.rz.gz) then
#           echo gunzip $aonname.rz.gz
#           gunzip $aonname.rz.gz
#         endif
#         if(-e $aonname.rz) then           # If parameterized
#                                         # ON-files already exist
#           echo $aonname.rz already exists.
#           echo Skipping gparamdat for the file $aonname.
#           set statusgpon = 0              # Set status good for gparamdat
#         else                              # Track mode but parameterize not done
          if($statuscpon == 0) then       # If codepeds step is ok
            if ($trigger != "91") then 
              echo gparamdat_331 $aonname $prlist[$idate] $prlist[$initro]\
                $pdatcontrol >> last.ql
              echo gparamdat_331 $aonname $prlist[$idate] $prlist[$initro]\
                $pdatcontrol
              gparamdat_331 $aonname $prlist[$idate] $prlist[$initro]\
                $pdatcontrol  
            else
              echo gparamdat $aonname $prlist[$idate] $prlist[$initro]\
                $pdatcontrol >> last.ql
              echo gparamdat $aonname $prlist[$idate] $prlist[$initro]\
                $pdatcontrol
              gparamdat $aonname $prlist[$idate] $prlist[$initro]\
                $pdatcontrol  
            endif
            set statusgpon = $status
          else
            set statusgpon = 1            # If codepeds fails, paramdat also
                                        # must fail
          endif # if statuscpon is good
#         endif # if .rz, .pdat exist
### 
# Added 951017 - Add entry to pawon.kumac if tracking mode completed
# successfully
          if(($statusgpon == 0)&&($trackmode == "track")) then
            echo CHAIN allon $aonname.rz >> pawon.kumac
            echo "inon = [inon] + 1" >> pawon.kumac
          endif
#
###
          if(($statusgpon == 0)&&($trackmode == "onoff")) then
                                        # If the ON source param. was succ.
                                        # completed and this is ON/OFF then
                                        # try to param. and cut OFF run.
#
# Commented-out by JB 950706
#           if(-e $aoffname.rz.gz) then     # This code is now redundant.  None
#                                       # of the analysis is done if .rz
#                                       # files exist.  This is left in, in
#                                       # case I decide to remove this feature
#                                       # later.
#             echo gunzip $aoffname.rz.gz
#               gunzip $aoffname.rz.gz
#             endif
#           if(-e $aoffname.rz) then
#             echo $aoffname.rz already exists.
#             echo Skipping gparamdat for the file $aoffname.
#             echo $aonname $aoffname >> pairs
#             echo CHAIN allon $aonname.rz >> pawon.kumac
#             echo CHAIN allof $aoffname.rz >> pawoff.kumac
#             echo "inon = [inon] + 1" >> pawon.kumac
#             echo "inoff = [inoff] + 1" >> pawoff.kumac
#                                       # Add the pair to the pairs file
#                                       # used by tabdat.
#             set statusgpoff = 0           # Set status good for gparamdat
#           else                           # If the off was not parameterized
            if($statuscpon == 0) then     # if status from codepeds ok, param...
              if($trigger != "91") then
                echo gparamdat_331 $aoffname $prlist[$idate] $prlist[$initro]\
                  $pdatcontrol >> last.ql
                echo gparamdat_331 $aoffname $prlist[$idate] $prlist[$initro]\
                  $pdatcontrol
                gparamdat_331 $aoffname $prlist[$idate] $prlist[$initro]\
                  $pdatcontrol
                set statusgpoff = $status
              else
                echo gparamdat $aoffname $prlist[$idate] $prlist[$initro]\
                  $pdatcontrol >> last.ql
                echo gparamdat $aoffname $prlist[$idate] $prlist[$initro]\
                  $pdatcontrol
                gparamdat $aoffname $prlist[$idate] $prlist[$initro]\
                  $pdatcontrol
                set statusgpoff = $status
              endif
              if($statusgpoff == 0) then  # If param. completed successfully...
                echo $aonname $aoffname >> pairs
#               echo $aonname $aoffname >> pawpairs
                echo CHAIN allon $aonname.rz >> pawon.kumac
                echo CHAIN allof $aoffname.rz >> pawoff.kumac
                echo "inon = [inon] + 1" >> pawon.kumac
                echo "inoff = [inoff] + 1" >> pawoff.kumac
              endif       # if paramdat off status is good
            endif         # if codeped status
#           endif           # if .rz, .pdat exist
# 
# Mod. 950726 - delete or compress even if gparamdat fails
#
            if($pcflag == "true") then   
              if($copyoff == "true") then
#               echo "Warning: removing ./"$aonname
#               /bin/rm ./$aonname
                echo "Warning: removing ./"$aoffname
                if(-e $aoffname) then
                  /bin/rm ./$aoffname
                endif
                if(-e $aoffname.gz) then
                  /bin/rm ./$aoffname.gz
                endif
              else
#               $TIDY_COMPRESS ./$aonname         
                $TIDY_COMPRESS ./$aoffname                # FORCED SPACE CONSERVATION
              endif
            else
#             $TIDY_COMPRESS ./$aonname           # FORCED SPACE CONSERVATION
              $TIDY_COMPRESS ./$aoffname          # FORCED SPACE CONSERVATION
            endif

            if($statusgpoff == 0) then      # If this is on/off and both param. 
                                        # have completed successfully...
              if(-e $aonname.pdat) then
                echo gcutdat $aonname 27 >> last.ql # Log it
                echo gcutdat $aonname 27            # Echo it
                cutdat $aonname 27                  # Cut ON-file to 27 minutes
              endif
              if(-e $aoffname.pdat) then
                echo gcutdat $aoffname 27 >> last.ql        
                echo gcutdat $aoffname 27           
                cutdat $aoffname 27                 # Cut OFF-file to 27 minutes
              endif
            endif # end if statusgpoff
          endif # end if statusgpon and on/off mode
        endif # end if statusfzon
        if (-e $aonname.rz) then   # If ntuple files were created, paw them
          if((-e $aonname"_ql".ps)||(-e $aonname"_ql".ps.gz)) then
            echo $aonname"_ql".ps already exists, skipping quicklook.kumac
          else 
            echo exec quicklook $aonname >> $qlrun
          endif
          if((-e $aonname"_dg".ps)||(-e $aonname"_dg".ps.gz)) then
            echo $aonname"_dg".ps already exists, skipping diagnostic.kumac
          else 
            if((-e $aonname"_d".hbook)||(-e $aonname"_d".hbook.gz)) then
              echo exec diagnostic $aonname >> $qlrun
            else
              echo $aonname"_d".hbook does not exist, skipping diagnostic.kumac
            endif
          endif
          if(($trackmode == "onoff") && (-e $aoffname.rz)) then
            if((-e $aoffname"_ql".ps)||(-e $aoffname"_ql".ps.gz)) then
              echo $aoffname"_ql".ps already exists, skipping quicklook.kumac
            else 
              echo exec quicklook $aoffname >> $qlrun
            endif
            if((-e $aoffname"_dg".ps)||(-e $aoffname"_dg".ps.gz)) then
              echo $aoffname"_dg".ps already exists, skipping diagnostic.kumac
            else 
              if((-e $aoffname"_d".hbook)||(-e $aoffname"_d".hbook.gz)) then
                echo exec diagnostic $aoffname >> $qlrun
              else
                echo $aoffname"_d".hbook does not exist, skipping diagnostic.kumac
              endif
            endif
            echo exec alphatot $sourcename 1 $aonname $aoffname >> $qlrun
          else if($trackmode == "track") then
            echo exec alphatot $sourcename 1 $aonname none >> $qlrun
          endif
        endif # end if ntuples were created
      endif # end else on/off with off file or tracking mode
#
# Mod by JB 950726 - wasn't doing rm or compress for tracking runs
#
      if($pcflag == "true") then   
        if($copyon == "true") then
          echo "Warning: removing ./"$aonname
          if(-e $aonname) then
            /bin/rm ./$aonname
          endif
          if(-e $aonname.gz) then
            /bin/rm ./$aonname.gz
          endif
        else
          $TIDY_COMPRESS ./$aonname               
        endif
      else
        $TIDY_COMPRESS ./$aonname               # FORCED SPACE CONSERVATION
      endif
#
    endif # end if found on
  endif # end else .rz files don't exist
  @ ion += 4
  @ ioff += 4
  @ initro += 4
  @ idate += 4
  @ k++
end # end while

echo gtabdat_vdev >> last.ql

ls *.cdat >>& /dev/null
if((-e pairs)&&($status == 0)) then     # If the pairs file exists and
                                        # at least one pair of cut on/off
                                        # files exists then tabulate data...
  echo gtabdat_vdev
  gtabdat_vdev
  echo tab.out\:
  cat tab.out
endif
@ idate -= 4

# set pawargs = `cat pawpairs`          # As a last step produce a combined
                                        # alpha plot (assuming these are all
                                        # runs for a single source
# echo lps alpha_$prlist[$idate] >> $qlrun
echo "kuip/wait 'Pausing for 3 seconds' 3" >> $qlrun
# echo exec alphatot $pawargs >> $qlrun
echo "vec/input non [inon]" >> pawon.kumac     # Return number of on/off        
echo "vec/input noff [inoff]" >> pawoff.kumac  # runs through scalers non,noff  
echo "return" >> pawon.kumac
echo " " >> pawon.kumac
echo "return" >> pawoff.kumac
echo " " >> pawoff.kumac
echo exec alphatot $sourcename 0 $firston >> $qlrun
                                # No parameters means build on and off
                                # chain using pawon.kumac pawoff.kumac
                                # rather than command line arguments
echo exit >> $qlrun

# Only run paw if there are some .rz files.
ls *.rz >>& /dev/null   
if($status == 0) then
  /cern/94a/bin/pawX11 < $qlrun
endif

if($pcflag == "true") then
  ls *.rz >>& /dev/null
  if($status == 0) then
    echo Compressing all .rz files
    $TIDY_COMPRESS *.rz
  endif
  ls *.pdat >>& /dev/null
  if($status == 0) then
    echo "Warning: removing *.pdat"
    /bin/rm *.pdat
  endif
endif

unset i
unset j
unset k
unset n2list
unset prlist
unset stlist
# unset pawargs
unset pathnum
unset pathlist
unset statuslist
unset cutlist
unset fullname
unset abbrname
unset answer
unset fonname
unset foffname
unset aonname
unset aoffname
unset statusfzon
unset statusfzoff
unset statuscpon
unset statuscpoff
unset statusgpon
unset statusgpoff

echo Done executing analyze script.
echo "Clean up files created by analyze (y/n)?"
if($batchmode == "false") then
  set answer = $<
else
  set answer="n"
endif
if(($answer == "y")||($answer == "Y")) then
  /bin/rm fort.*
  if(-e paths) /bin/rm paths
  if(-e dat.config) /bin/rm -i dat.config
  if(-e alphatot.kumac) /bin/rm -i alphatot.kumac
  if(-e quicklook.kumac) /bin/rm quicklook.kumac
  if(-e diagnostic.kumac) /bin/rm diagnostic.kumac
  if(-e last.kumac) /bin/rm last.kumac
# if(-e last.kumacold) /bin/rm last.kumacold
  if(-e fort.3) /bin/rm fort.3
  if(-e fort.7) /bin/rm fort.7
  if(-e paw.metafile) /bin/rm paw.metafile
  if(-e temp) /bin/rm temp
  if(-e pairs) /bin/rm pairs
  if(-e hrc.pairlist) /bin/rm hrc.pairlist
  if(-e zen.dat) /bin/rm zen.dat
endif
unset answer
unset batchmode
exit 0

#--------------------------------------------------------------------
# The following forms the contents of a file named "paths" which is
# created if no file of this name is found in the current directory.
# The first two characters are necessary to flag the lines
# of analyze belonging to "paths" for the extraction script.
# This file is gives the path first of the input files for analysis
# and then the output path.  For this script these are trivially
# set to the working directory, i.e. "."
#p .
#p .
#---------------------------------------------------------------------
# The following forms the contents of a file called "dat.config" which is extracted to perform
# the run.  This is included to make the script more self contained
# and to avoid confusion about which files are needed by the various
# analysis routines.  

#! # Configuration file for data analysis.
#! #
#! # Blank lines and those beginning with "#" or " " are considered comments
#! #
#! #
#! #
#! #
#! # A line with the first three characters being "par" introduce the
#! # section used by paramdat
#! #
#! 
#! par:             #Section used by paramdat
#! 
#! # Line 1 is the path of the data file
#! 
#! .
#! 
#! #
#! # Line 2 is the path for calibration files, other than hrc.ntubelist.
#! 
#! default
#! 
#! #
#! # Line 3 is path for hrc.ntubelist.  This allows you to
#! # play with turning off tubes independently of other calibrations.
#! 
#! default
#! 
#! #
#! # Line 4 gives the path for the output files.
#! 
#! .
#! 
#! #
#! # Line 5 gives required picture and boundary thresholds
#! 
#! 4.25 2.25
#! 
#! #
#! # If first character of next line is 'y' or 'Y', then we do padding;
#! # otherwise we skip it.
#! 
#! Yes padding
#! 
#! #
#! # If we did want to pad, a final line in the parameterize section gives
#! # give the path of the hrc.pairlist file.
#! 
#! .
#! 
#! # You can specify the number of tubes to use in the parameterization here 
#! # or leave it as 0 to use all tubes.
#! 
#! 379
#! 
#! #
#! ###################################
#! #
#! #
#! #
#! # A line beginning with "cut" introduces the section used by cutdat.
#! 
#! cut:
#! 
#! # Path of input files *.pdat
#! 
#! .
#! 
#! # Path of output files *.cdat
#! 
#! .
#! 
#! # Codes we wish to include in analysis.  All will be cut with the
#! # same values.  A string of 12 integers are required; it is anticipated
#! # that the code will be in the corresponding column, but this probably
#! # is unnecessary.
#! 
#! 8  0  0  0  0  0  0  0  0  0  0  0
#! 
#! # Next is number of sidereal minutes to which file will be cut if
#! # the second argument is not entered on the command line.  99999 is a
#! # sufficiently large number that the entire file will be read in this case.
#! 
#! 99999.
#! 
#! # If the first character is 'y' or 'Y', then cut the beginning of the
#! # file before the first code 7 event; otherwise, start analysis at the
#! # very beginning of the file.
#! 
#! No, cut before the first sidereal minute marker.
#! 
#! # Next line has the same format as last, and controls if we should cut
#! # events which trigger the veto
#! 
#! No, kill events triggering veto.
#! 
#! # Now come the cuts, which are passed if cut(0)<val<cut(1)
#! 
#! # Width
#! 0.073 0.15
#! 
#! # Length
#! 0.16 0.30
#! 
#! # Dist
#! 0.51 1.1
#! 
#! # Alpha (sin(alpha)<cut to pass)
#! 0.17365
#! 
#! # Trigger multiplicity (out of 91) and level (digital counts)
#! # max(mult)<cut fails the event
#! 2 45.
#! 
#! # Size cut (size<cut kills event)
#! 0.
#! 
#! # That's it for cuts
#! 
#! # Now the number of bins for the alpha plot
#! 18
#! 
#! #
#! ####################################
#! #
#! #
#! #
#! # The section for tabdat is introduced by tab
#! #
#! 
#! tab:
#! 
#! # First is path of data files *.cdat
#! 
#! .
#! 
#! # Next is name of file containing list of pairs
#! 
#! ./pairs
#! 
#! # Then is name of output file to hold final table
#! 
#! ./tab.out
#! 
#! #
#! #####################################
#! #
#! #
#! #
#! # The section for alpha is introduced by alp
#! #
#! 
#! alp:
#! 
#! # First is path of data files *.cdat
#! 
#! .
#! 
#! # Nexit is name of file containing list of files to analyze
#! 
#! ./files
#! 
#! # Next come 3 numbers specifying how significance is to be computed from
#! # the alpha plot.  All numbers are in degrees.  Values below the first number
#! # are the signal bins.  Values between the next two numbers are used to
#! # calculate the background.  Other bins are ignored.  This is done since some
#! # signal may be spilling over at the high end, and the alpha plots for 1994
#! # seem to tail off at high values.
#! 
#! 15. 20. 65.
#! 
#! # Last is name of output list file
#! 
#! ./alp.out

#--------------------------------------------------------------------
# The following forms the contents of "alphatot.kumac" and
# "quicklook.kumac" which are 
# created by automatic extraction from this script
#
#pal  MACRO alphatot
#pal *
#pal * JB 951016
#pal *
#pal * exec alphatot [sourcename] [mode] [datafile, ...]
#pal *
#pal *           sourcename       String with no blanks containing source name
#pal *           mode             0 - use chains in pawon.kumac, pawoff.kumac
#pal *                            1 - build chains w/ cmd line args
#pal *           datafile         Data filename in the format gt????
#pal *                                give first filename even if creating chain
#pal *                               
#pal * Revision History (incomplete):
#pal *
#pal * JB 951016 
#pal * Added nicer 2-d plots, and control flags to reconfigure output.  Also
#pal * added code to generate a detailed table of results.  tab.tmp is
#pal * produced to give one row of a table corresponding to the first on/off
#pal * pair of the chain (or trk run), and is automatically appended to 
#pal * runtab.out
#pal *
#pal * JB 950715
#pal * Expanded version of JQ's alphatime.kumac, to accumulate results of 2-d
#pal * analysis, and display ON-OFF pedestal variances for a pointing check.
#pal *
#pal * JQ 950630 
#pal * PAW script which cuts parameterised .rz files(pairs only, no tracking)
#pal * Based on Jim Buckley's alphatot.kumac but with severeal differences-
#pal * mainly the use of selection functions and duration matching.
#pal * The script matches durations carefully, but is slow as this requires 2
#pal * passes through the ntuple chain. The run-by-run durations are calculated
#pal * for each on/off pair and each pair is cut to the smaller of that pair.
#pal * Requires pawon and pawoff kumacs which generate chains and return into
#pal * vectors inonn and inoff the number of pairs. The selection function
#pal * for the first pass is durations.f and for the second pass is cut_time.f
#pal * Modified (JQ 950704) so that it uses selection functions from the dir
#pal * /data5/quinn/paw/uwfunc/analyse3 and this directory is pointed to by 
#pal * the variable [comisdir]
#pal *
#pal * MC 960209
#pal * Change script so that the size and trigger can have upper bounds as 
#pal * well as lower ones.  The upper bounds are used as or statements
#pal * (i.e., the event is kept if ((t10totsig.lt.size(2)).or.
#pal * (t10max1.lt.max1(2)).or.(t10max2.lt.max2(2))).  So if you want to
#pal * just apply a size upper bound, set max1(2)=-1. and max2(2)=-1. so
#pal * that the logical is false if size < the upper bound.  This is to allow 
#pal * one to look only at small events.  This entails switching from 
#pal * using trig(2) for setting the triggers to using max1(2) and max2(2).
#pal *
#pal * MC 960212
#pal * Add options in analyze script that will remove certain comment lines 
#pal * if certain commands exist in the commad list script.  Those cuts 
#pal * below with no * or which have *std in front of them are the current 
#pal * standard analysis cuts.  Those cuts with no * or which have *ltl in 
#pal * front of them are the current standard littlelovers cuts.
#pal * MC 961108
#pal * Change low elevation cuts to Frank K.'s current best guess.
#pal *
#pal *
#pal * JQ 970304 Changed cuts to new optimum cuts for 151 pixel camera
#pal *
#pal * MC 990831 Though not noted here, there have been many changes to this
#pal * kumac file.  Here, adapt for the new graded camera with 379 inner
#pal * small tubes and 111 bigger tubes.  The alphatot whipcam MACRO was
#pal * changed and things made less dependent on settings located all over.
#pal *
#pal set *
#pal opt *
#pal igset *
#pal comisdir='/usr/local/whipple/src/vpro/alphatot2/' |Home dir for sel.funcs.
#pal dbdir='/usr/dbgt/pgvec/'
#pal dbdirw='/usr/dbgt/'
#pal *
#pal ************************************************************************
#pal * Edit the following block of code to change cuts, on/off alpha        *
#pal * ratio etc.
#pal *
#pal * Define cuts (note if any new cuts are added or any are removed then the 
#pal * cut selection function (in directory [comisdir]) cut_time.f, the comis
#pal * routine for writing the start of the pawtab.out file and routine which
#pal * prints the text on the picture (in this macro) must also be edited.
#pal *
#pal * NOTE: If you want to apply only a size upper bound and not a trigger
#pal *  upper bound, you must set max(1)=-1. and max2(2)=-1. so that the
#pal *  logical in the comis function cut_time.f (which uses the .or.
#pal *  connector) will always be false if size < upper bound.  Similarly,
#pal *  to apply solely a trigger upper bound, set size(2)=-1.
#pal *
#pal * These are the same for all analysis
#pal vec/cre efarea(1) r 3.5        | Effective area [x 10^8 cm^2]
#pal vec/cre nbr3(1) r 0.5          | >0 means this cut is 'on'
#pal vec/cre asymm(1) r -1000.0     | Turn off Asymmetry cut
#pal *vec/cre asymm(1) r 0.0  
#pal *vec/cre offal(2) r 15. 65.
#pal vec/cre offal(2) r 20. 65.
#pal *
#pal * Test supercuts
#pal *std vec/cre max1(2) r 30.0 9999.0
#pal *std vec/cre max2(2) r 30.0 9999.0
#pal *std vec/cre size(2) r 0.0 999999.0  |totsig > size(1) and < size(2)
#pal *std vec/cre dist(2) r 0.40 1.0
#pal *sjfdh vec/cre dist(2) r 0.51 1.1
#pal *std vec/cre width(2) r 0.05 0.12
#pal *std vec/cre length(2) r 0.13 0.25
#pal *std vec/cre lot(2) r 0. 0.0004
#pal *std vec/cre alpha(1) r 15.         | in degrees 
#pal * vec/cre roffon(1) r 3.0           | OFF/ON alpha ratio
#pal *std vec/cre roffon(1) r 3.20       | OFF/ON alpha ratio
#pal *
#pal * Standard Supercuts for 331 camera, 1998 
#pal *st98 vec/cre max1(2) r 75.0 9999.0
#pal *st98 vec/cre max2(2) r 65.0 9999.0
#pal *st98 vec/cre size(2) r 0.0 999999.0  |totsig > size(1) and < size(2)
#pal *st98 vec/cre dist(2) r 0.51 1.25
#pal *st98 vec/cre width(2) r 0.07 0.16
#pal *st98 vec/cre length(2) r 0.16 0.44
#pal *st98 vec/cre alpha(1) r 10.         | in degrees
#pal *st98 vec/cre offal(2) r 20. 65.
#pal *st98 vec/cre roffon(1) r 4.5        | OFF/ON alpha ratio
#pal *st98 vec/cre lot(2) r 0. 1000.      | no len/size cut
#pal *st98 vec/cre asymm(1) r 0.0         | include asymmetry
#pal *
#pal * Standard Supercuts for 151 camera, 1997 
#pal *st97 vec/cre max1(2) r 95.0 9999.0
#pal *st97 vec/cre max2(2) r 45.0 9999.0
#pal *st97 vec/cre size(2) r 0.0 999999.0  |totsig > size(1) and < size(2)
#pal *st97 vec/cre dist(2) r 0.51 1.17
#pal *st97 vec/cre width(2) r 0.073 0.16
#pal *st97 vec/cre length(2) r 0.16 0.33
#pal *st97 vec/cre alpha(1) r 15.         | in degrees
#pal *st97 vec/cre offal(2) r 20. 65.
#pal *st97 vec/cre roffon(1) r 3.0        | OFF/ON alpha ratio
#pal *st97 vec/cre lot(2) r 0. 1000.      | no len/size cut
#pal *st97 vec/cre asymm(1) r 0.0     | include asymmetry
#pal *
#pal * Standard supercuts 151
#pal *st1 vec/cre max1(2) r 95.0 9999.0
#pal *st1 vec/cre max2(2) r 45.0 9999.0
#pal *st1 vec/cre size(2) r .0 999999.0  |totsig > size(1) and < size(2)
#pal *st1 vec/cre dist(2) r 0.51 1.17
#pal * vec/cre dist(2) r 0.51 1.0
#pal *st1 vec/cre width(2) r 0.073 0.16
#pal *st1 vec/cre length(2) r 0.16 0.33
#pal *st1 vec/cre lot(2) r 0. 1000.0     | Turn off Length/Size cut
#pal *st1 vec/cre alpha(1) r 10.         | in degrees
#pal * vec/cre roffon(1) r 5.0       | OFF/ON alpha ratio
#pal *st1 vec/cre roffon(1) r 3.0      | OFF/ON alpha ratio
#pal * vec/cre roffon(1) r 5.26       | OFF/ON alpha ratio
#pal *
#pal * Littlelovers cuts 
#pal *ltl vec/cre size(2) r 0.0 400.0   |totsig > size(1) and < size(2)
#pal *ltl vec/cre max1(2) r 45.0 100.0
#pal *ltl vec/cre max2(2) r 45.0 80.0
#pal *ltl vec/cre dist(2) r 0.51 1.1
#pal * vec/cre dist(2) r 0.51 1.0
#pal *ltl vec/cre width(2) r 0.073 0.15
#pal *ltl vec/cre length(2) r 0.16 0.3
#pal *ltl vec/cre lot(2) r 0. 0.00075
#pal *ltl vec/cre alpha(1) r 10.         | in degrees
#pal *ltl vec/cre roffon(1) r 5.00       | OFF/ON alpha ratio
#pal *
#pal * Low elevation cuts
#pal *lel vec/cre size(2) r 300.0 999999.0   |totsig > size(1) and < size(2)
#pal *lel vec/cre max1(2) r 45.0 9999.0
#pal *lel vec/cre max2(2) r 45.0 9999.0
#pal *lel vec/cre dist(2) r 0.51 1.1
#pal * vec/cre dist(2) r 0.51 1.0
#pal *lel vec/cre width(2) r 0.05 0.12
#pal *lel vec/cre length(2) r 0.14 0.25
#pal *lel vec/cre lot(2) r 0. 1000.0
#pal *lel vec/cre alpha(1) r 10.         | in degrees
#pal *lel vec/cre roffon(1) r 5.00       | OFF/ON alpha ratio
#pal ************************************************************************
#pal * Number of tubes in the camera
#pal ************************************************************************
#pal ntb = 490
#pal *
#pal ************************************************************************
#pal * Edit the following flags to control the format of the output
#pal *
#pal fsig2d = 0 | Generate a 2-d signif. plot regardless of the mode
#pal fex2d = 0  | Generate a 2-d excess plot instead of pedvar
#pal fshcon = 1 | Shade significance and excess contour plots
#pal fupo2d = 0      | If fex2d.and.fupo2d then show "unique point of origin"
#pal *                 excess plot instead of mesh excess plot
#pal fascii = 1 | Generate an ascii tab.out file
#pal fpicts = 0      | Generate separate picture files of alpha and 2d
#pal fbare = 0  | If gen. pict files of 2d, show no stars etc...
#pal flstar = 1 | Flip stars in 2-d plot so RA increases to left
#pal fcolor = 0 | Toggle between color and grayscale plots
#pal nlevel = 20        | Number of color or gray levels: 20 is max for grays
#pal maxsig = 6 | Maximum significance corresponding to the nlevel
#pal *
#pal *                                                                      *
#pal ************************************************************************
#pal sigma sinalp=sin(alpha(1)*pi/180)
#pal vec/cre offsa(2) r $sigma(sin(offal(1)*pi/180)) $sigma(sin(offal(2)*pi/180))
#pal *
#pal vec/cre cv(19) r dist(1) dist(2) width(1) width(2) length(1) length(2) _
#pal    size(1) size(2) max1(1) max1(2) max2(1) max2(2) nbr3(1) sinalp(1) _ 
#pal    offsa(1) offsa(2) lot(1) lot(2) asymm(1)
#pal *
#pal cut1=$eval(dist(1))"L# Distance "L#$eval(dist(2))
#pal cut2=$eval(width(1))"L# Width "L#$eval(width(2))
#pal cut3=$eval(length(1))"L# Length "L#$eval(Length(2))
#pal cut4=Size "G#$eval(size(1)), 1/91"G#$eval(max1(1)), 2/91"G#$eval(max2(1))
#pal cut5=Size"L#$eval(size(2)) or 1/91"L#$eval(max1(2)) or 2/91"L#$eval(max2(2))
#pal cut6=Nbr3 "G#$eval(nbr3(1))
#pal cut7=[a]"L#$eval(alpha(1))^o!
#pal cut8=$eval(offal(1))"L#[a]"L#$eval(offal(2))^o!
#pal cut9=$eval(lot(1))"L# Length/Size "L#$eval(lot(2))
#pal cut10=Asymmetry "G#$eval(asymm(1))
#pal *
#pal opt nbox            | no box around plot
#pal opt a4
#pal opt linx
#pal opt liny
#pal set mtyp 1          | marker type
#pal set xlab 1.5        | dist label to y-axis (default = 1.4)
#pal set ylab 0.9        | dist label to x-axis (default = 1.4)
#pal set xwin 2.0        | x-dist between plots (default = 2.0)
#pal set ywin 2.0        | y-dist between plots (default = 2.0)
#pal set asiz 0.28          | axis label size (default = 0.28)
#pal set XMGL 3.0        | Margins (defualt = 2.0)      
#pal set XMGR 2.0
#pal set YMGL 2.0
#pal set YMGU 3.0
#pal opt linx
#pal opt liny
#pal opt nsta
#pal set HTYP 0
#pal * zon 2 3 
#pal zon 2 3
#pal * h/del *
#pal *
#pal for/file 1 'cuton.tmp' 
#pal for/file 2 'cutoff.tmp'
#pal vec/cre non(1) i 0        | no. of on runs.
#pal vec/cre noff(1) i 0       | no. of off runs.
#pal vec/cr npmt(1) i [ntb]
#pal *
#pal vec/cr xr([ntb]) R
#pal vec/cr yr([ntb]) R
#pal vec/cr ped([ntb]) R
#pal vec/cr pedvar([ntb]) R
#pal vec/cr dped([ntb]) R
#pal vec/cr gain([ntb]) R
#pal vec/cr meanpv(1) R | mean ped. variance
#pal *
#pal * Define vectors to store results from the COMIS function
#pal * ulcomis.f
#pal *
#pal vec/cr sigoo(1) R
#pal vec/cr uloo(1) R
#pal vec/cr rateoo(1) R
#pal vec/cr fluxoo(1) R
#pal vec/cr ulfloo(1) R
#pal vec/cr sigtr(1) R
#pal vec/cr ultr(1) R
#pal vec/cr ratetr(1) R
#pal vec/cr fluxtr(1) R
#pal vec/cr ulfltr(1) R
#pal *
#pal vec/cr fra(1) R
#pal vec/cr fdec(1) R
#pal vec/cr favel(1) R
#pal vec/cr futdat(1) R
#pal vec/cr fmjd(1) R
#pal vec/cr fsigtr(1) R
#pal vec/cr favetr(1) R
#pal *
#pal * Added 951011 - xaave, yaave global vars returning the position of
#pal * the centroid of the brightest spot in the pedvar.
#pal *
#pal vec/cr xaave(1) R
#pal vec/cr yaave(1) R
#pal *
#pal vec/cr rafmt(1) R
#pal vec/cr decfmt(1) R
#pal vec/cr xbs(100) R
#pal vec/cr ybs(100) R
#pal vec/cr mbs(100) R
#pal vec/cr nbs(1) i
#pal *
#pal inon = 0
#pal inoff = 0
#pal source = ' '
#pal nfirst = 1
#pal *
#pal IF [#] > 0 THEN
#pal   source = [1]
#pal   nfirst = 2
#pal   IF [#] > 1 THEN
#pal     chmode = [2]
#pal     nfirst = 3
#pal     IF [#] > 2 THEN
#pal       ffile = [3]
#pal     ENDIF
#pal   ENDIF
#pal ENDIF
#pal *      
#pal IF [chmode].eq.1 THEN
#pal   fex2d = 0
#pal ENDIF
#pal ******************** MAC 990625
#pal * The lines below get the dimensions of the 2D histograms for use in
#pal * defining the 2D histograms below.
#pal h/file 4 [ffile].h2d
#pal h/copy 11 111
#pal nx = $HINFO(111,'XBINS')
#pal nx2 = [nx]/2.
#pal v/cr nmx(2) r [nx] [nx2]
#pal ny = $HINFO(111,'YBINS')
#pal v/cr nmy(1) r [ny]
#pal ny2 = [ny]/2
#pal v/cr nmy(2) r [ny] [ny2]
#pal xmin = $HINFO(111,'XMIN')
#pal xmax = $HINFO(111,'XMAX')
#pal ymin = $HINFO(111,'YMIN')
#pal ymax = $HINFO(111,'YMAX')
#pal *MESS 'nx,ny = '//[nx]//','//[ny]
#pal *MESS 'xmin,xmax = '//[xmin]//','//[xmax]
#pal *MESS 'ymin,ymax = '//[ymin]//','//[ymax]
#pal h/del 111
#pal CLOSE 4
#pal ********************
#pal *
#pal CHAIN -
#pal IF ([#] > 0).and.([chmode].eq.1) THEN
#pal   DO i=[nfirst],[#],2
#pal     IF [%i] <> 'none' THEN
#pal       CHAIN allon [%i].rz
#pal       inon = [inon] + 1
#pal     ENDIF
#pal   ENDDO
#pal   fnames = ''
#pal   DO i=[nfirst],[#],1
#pal     fnames = [fnames]//' '//[%i]
#pal   ENDDO
#pal ELSE
#pal   exec pawon.kumac
#pal   inon = non       | This is a way of using a scaler to pass
#pal                 | a variable to a macro, and return a var.
#pal ENDIF
#pal *
#pal nfirst = [nfirst]+1
#pal *
#pal IF ([#] > 0).and.([chmode].eq.1) THEN
#pal   DO i=[nfirst],[#],2
#pal     IF [%i] <> 'none' THEN
#pal       CHAIN allof [%i].rz
#pal       inoff = [inoff] + 1
#pal     ENDIF
#pal   ENDDO
#pal * title 'Alpha for runs"J#'//[*]
#pal   title [source]//' Analysis for runs"J#'//[fnames]//' '//$DATE
#pal ELSE
#pal   exec pawoff.kumac
#pal   inoff = noff
#pal * title 'Alpha for '//[inon]//' on, '//[inoff]//' off runs'
#pal   title _
#pal [source]//' Analysis for '//[inon]//' on, '//[inoff]//' off runs'//' '//$DATE
#pal ENDIF
#pal *
#pal IF ([#] > 2) THEN
#pal   vec/read xr,yr,ped,pedvar,dped,gain [dbdir][ffile].pgvec
#pal ENDIF
#pal *
#pal message [inon]//' ON runs'
#pal message [inoff]//' OFF runs'
#pal if [inon].ne.[inoff] then
#pal   message 'WARNING: Number of OFF runs does not match number ON.'
#pal   message 'Doing tracking analysis'
#pal * message 'Exiting macro...'
#pal * goto end
#pal endif
#pal *
#pal if [inon].eq.0 then
#pal   message 'No ON runs - Exiting macro...'
#pal   goto end
#pal endif
#pal *
#pal vec/cre npairs(1) i [inon]
#pal np=[inon]
#pal *
#pal vec/cre mindurs([np]) r
#pal vec/inp mindurs [np]*0.00001
#pal vec/cre ondurs([np]) r               |vector containing durations of 'on' runs
#pal vec/cre offdurs([np]) r      |vector containing durations of 'off' runs
#pal vec/cre durs([np]) r                 |vector containing durations of runs
#pal                              |Using real for time means can hold
#pal                              |166,666 mins (over 5,000 30 min runs) 
#pal                              |to within 1 sec accuracy
#pal *  
#pal vec/cre stats(2,8) i         |vector containing raw,nbr3,trigger,shape
#pal                              |shape20-90,orientation,gammas
#pal                                   |and offalpha - JB 950720  for on
#pal                              |& off. (1,:) is on and (2,:) is off.
#pal                              |Using integer for these vectors means
#pal                              |we can store 999,999,999 events 
#pal                              |(over 11,000 runs at 50 Hz). If we had 
#pal                              |used real for the vector type we could 
#pal                              |only have stored the events for 111 
#pal                              |runs (at 50Hz.). The drawback is that 
#pal                              |SIGMA will not work on integervectors 
#pal                              |(SIGMA is crap anyway) so a fortran
#pal                              |function will have to be written to do 
#pal                              |calculations of significances. 
#pal vec/cre sigmas(8) r
#pal *
#pal cd //allon
#pal message 'First pass - Calculating run durations for ON.'
#pal chain allon>
#pal nt/loop 100 [comisdir]durations.f(1.0) |1 means 'ON' data
#pal vec/copy durs ondurs                 |and 2 means 'OFF' data.
#pal *
#pal IF [inon].eq.[inoff] THEN
#pal   cd //allof
#pal   message ' '
#pal   message ' '
#pal   message ' '
#pal   message 'First pass - Calculating run durations for OFF.'
#pal   chain allof>
#pal   nt/loop 100 [comisdir]durations.f(2.0)
#pal   vec/copy durs offdurs
#pal ELSE
#pal   vec/copy ondurs offdurs
#pal ENDIF
#pal *
#pal sigma ondurs=max(ondurs,mindurs)
#pal sigma offdurs=max(offdurs,mindurs)
#pal sigma durs=min(ondurs,offdurs)
#pal sigma tduron=vsum(ondurs)   |Wanted to call these totduron...
#pal sigma tduroff=vsum(offdurs)      |but sigma will not work with names
#pal sigma tdurcut=vsum(durs)         |of length > 7 character!
#pal *
#pal tempdur = $eval(tduron)          |Continue only if there is some data
#pal *mac IF [tempdur].gt.0.001 THEN
#pal *
#pal message ' '
#pal tmp=tduron(1)
#pal message 'Total duration of ON: '//[tmp]//' seconds.'
#pal IF [inon].eq.[inoff] THEN
#pal   tmp=tduroff(1)
#pal   message 'Total duration of OFF: '//[tmp]//' seconds.'
#pal   tmp=tdurcut(1)
#pal   message 'Total duration after cutting to ON/OFF minimum times:'_
#pal          [tmp]//' seconds.'
#pal ENDIF
#pal *
#pal IF [fpicts].eq.0 THEN
#pal   picture/create palph
#pal ENDIF
#pal *
#pal * Create 1-D histograms
#pal *
#pal h/cr/1d  1  ' ' 18 0.0 90.0                | ON Data
#pal h/cr/1d  2  ' ' 18 0.0 90.0                | OFF Data
#pal h/cr/1d  50  'ON-OFF ' 18 0.0 90.0 
#pal h/cr/1d  60  'ON+OFF ' 18 0.0 90.0 
#pal h/cr/1d  70  'Integral Excess ' 18 0.0 90.0 
#pal h/cr/1d  80  ' ' 18 0.0 90.0               | Integral Significance
#pal *
#pal * Create 2-D histograms
#pal *
#pal * h/cr/2d 21 'ON SCAT' 20 -2.0 2.0 20 -2.0 2.0
#pal * h/cr/2d 22 'OFF SCAT' 20 -2.0 2.0 20 -2.0 2.0
#pal *mac9 h/cr/2d 11 'ON MESH' 48 -2.4 2.4 48 -2.4 2.4
#pal *mac9 h/cr/2d 15 ' ' 48 -2.4 2.4 48 -2.4 2.4
#pal *mac9 h/cr/2d 16 ' ' 48 -2.4 2.4 48 -2.4 2.4
#pal *mac9 h/cr/2d 17 ' ' 24 -2.4 2.4 24 -2.4 2.4
#pal *mac9 h/cr/2d 18 ' ' 24 -2.4 2.4 24 -2.4 2.4
#pal h/cr/2d 11 'ON MESH' [nx] [xmin] [xmax] [ny] [ymin] [ymax]
#pal h/cr/2d 15 ' ' [nx] [xmin] [xmax] [ny] [ymin] [ymax]
#pal h/cr/2d 16 ' ' [nx] [xmin] [xmax] [ny] [ymin] [ymax]
#pal h/cr/2d 17 ' ' [nx2] [xmin] [xmax] [ny2] [ymin] [ymax]
#pal h/cr/2d 18 ' ' [nx2] [xmin] [xmax] [ny2] [ymin] [ymax]
#pal * h/cr/2d 17 ' ' 20 -2.0 2.0 20 -2.0 2.0
#pal * h/cr/2d 18 ' ' 20 -2.0 2.0 20 -2.0 2.0
#pal *
#pal v/cr dif(18)
#pal v/cr sum(18)
#pal v/cr on(18)
#pal v/cr intsum(18)
#pal v/cr intdif(18)
#pal v/cr intsig(18) R
#pal v/cr results(15) R
#pal v/cr ontime(2) R
#pal v/cr off(18)
#pal *
#pal v/cr temp(14) r
#pal v/cr bothon(1) r
#pal v/cr bothof(1) r
#pal *
#pal v/cr meshon([nx],[ny]) R
#pal v/cr meshoff([nx],[ny]) R
#pal v/cr difmesh([nx],[ny]) R
#pal v/cr summesh([nx],[ny]) R
#pal v/cr sigmesh([nx],[ny]) R
#pal *
#pal v/cr upoon([nx2],[ny2]) R
#pal v/cr upooff([nx2],[ny2]) R
#pal v/cr difupo([nx2],[ny2]) R
#pal v/cr sumupo([nx2],[ny2]) R
#pal v/cr sigupo([nx2],[ny2]) R
#pal *
#pal v/cr clevel(50) R
#pal v/input clevel(1:20) _
#pal 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 
#pal v/input clevel(21:40) _
#pal 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40.
#pal v/input clevel(41:50) _
#pal 41. 42. 43. 44. 45. 46. 47. 48. 49. 50.
#pal * v/cr clevel(50) R 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
#pal *
#pal * 951014 Get rid of some IF's to make PAW happy
#pal * 971119 If this is a tracking analysis use mode 3.0 (ignore duration)
#pal * IF [inon] > 0 THEN
#pal   MESSAGE ' '
#pal   MESSAGE ' '
#pal   MESSAGE '2nd pass - Cutting ON runs'
#pal   CHAIN allon>
#pal   CD //allon
#pal   if [inon].eq.[inoff] then
#pal    nt/loop 100 [comisdir]cut_time.f(1.0) 
#pal   else
#pal    nt/loop 100 [comisdir]cut_time.f(3.0) 
#pal   endif
#pal   hist/get/cont 11 meshon | Copy summed ON-mesh hist into a vector
#pal   hist/del 11             | Delete hist for accumulation of OFF-hists
#pal * ENDIF                                 
#pal *
#pal h/cr/2d 11 'OFF MESH' [nx] [xmin] [xmax] [ny] [ymin] [ymax]
#pal *
#pal IF [inoff] > 0 THEN
#pal   MESSAGE ' '
#pal   MESSAGE ' '
#pal   MESSAGE '2nd pass - Cutting OFF runs'
#pal   CHAIN allof>
#pal   CD //allof
#pal   nt/loop 100 [comisdir]cut_time.f(2.0)
#pal   hist/get/cont 11 meshoff | Copy summed OFF-mesh hist into a vector
#pal   hist/del 11
#pal ENDIF
#pal *
#pal sigma summesh=meshon+meshoff
#pal sigma difmesh=meshon-meshoff
#pal *
#pal * Sigma just isn't robust enough, check for divide by zero
#pal * sigma sigmesh=difmesh/sqrt(summesh)
#pal *
#pal hist/get/cont 17 upoon
#pal hist/get/cont 18 upooff
#pal sigma sumupo=upoon+upooff
#pal sigma difupo=upoon-upooff
#pal *
#pal * Sigma just isn't robust enough, check for divide by zero
#pal * sigma sigupo=difupo/sqrt(sumupo)
#pal *
#pal APPLIcation COMIS QUIT 
#pal       subroutine csig
#pal       vector summesh,difmesh,sigmesh,nmx,nmy
#pal       vector sumupo,difupo,sigupo
#pal       integer i,j,nx,ny,nx2,ny2
#pal       real denom
#pal *
#pal       nx = nmx(1)
#pal       ny = nmy(1)
#pal       nx2 = nmx(2)
#pal       ny2 = nmy(2)
#pal       do i=1,nx
#pal         do j=1,ny
#pal           if summesh(i,j).lt.1.0 then
#pal             denom = 1.0
#pal           else
#pal             denom = summesh(i,j)
#pal           endif
#pal           sigmesh(i,j)=difmesh(i,j)/sqrt(denom) 
#pal         end do
#pal       end do
#pal *
#pal       do i=1,nx2
#pal         do j=1,ny2
#pal           if sumupo(i,j).lt.1.0 then
#pal             denom = 1.0
#pal           else
#pal             denom = sumupo(i,j)
#pal           endif
#pal           sigupo(i,j)=difupo(i,j)/sqrt(denom) 
#pal         end do
#pal       end do
#pal *  
#pal       end
#pal       call csig
#pal       end
#pal QUIT
#pal *
#pal IF [inon].eq.[inoff] THEN
#pal   call [comisdir]calc_sigs.f
#pal ENDIF
#pal *
#pal h/op/sub 1 2 50 1.0 1.0            | Histogram 50 is on-off
#pal h/op/add 1 2 60 1.0 1.0            | Histogran 60 is on+off
#pal * 
#pal h/get/cont 50 dif          | Get contents of histograms intop vectors
#pal h/get/cont 60 sum                  
#pal h/get/cont 1 on
#pal h/get/cont 2 off               |JQ 950426          
#pal * 
#pal * xn = [#]/2
#pal * vec/input ontime [xn] 0.0
#pal vec/input ontime [inon] [inoff]
#pal * 
#pal APPLIcation COMIS QUIT 
#pal             SUBROUTINE LOOP
#pal             Vector dif
#pal             Vector sum
#pal             Vector intdif
#pal             Vector intsum
#pal             Vector intsig
#pal             Vector results
#pal             Vector on
#pal             Vector ontime
#pal        Vector tdurcut
#pal        Vector stats
#pal        Vector sigmas
#pal             Vector roffon
#pal *
#pal * ON/OFF analysis
#pal *
#pal        ngam=stats(1,7)-stats(2,7)
#pal        results(1)=ngam/(tdurcut(1)/60.0)
#pal        results(2)=sigmas(7)/SQRT(ontime(1))
#pal        results(3)=ngam
#pal        results(4)=sigmas(7)
#pal *
#pal * Tracking analysis
#pal *
#pal             results(11)=stats(1,7)-stats(1,8)/roffon(1) ! Excess
#pal             results(12)=(stats(1,7)+stats(1,8))/roffon(1)
#pal             if(results(12).gt.0.0) then
#pal               results(12) = sqrt(results(12))
#pal               if(results(12).gt.0.0) then
#pal                 results(12)=results(11)/results(12)
#pal               else
#pal                 results(12) = 0.0
#pal               endif
#pal             else
#pal               results(12) = 0.0
#pal             endif
#pal             results(13) = results(11)/(tdurcut(1)/60.0)
#pal             results(14) = results(12)/SQRT(ontime(1))
#pal *
#pal             xsum = 0.
#pal             xdif = 0.
#pal             xonmax = 0.
#pal             intdif(1) = dif(1)
#pal             intsum(1) = sum(1)
#pal             do 10 i=2,18
#pal               intsum(i) = intsum(i-1)+sum(i)
#pal               intdif(i) = intdif(i-1)+dif(i)
#pal             enddo
#pal    10       continue 
#pal             do 20 i=1,18
#pal               if(on(i).gt.xonmax) then
#pal                 xonmax = on(i)
#pal               endif
#pal               if(intsum(i).gt.0.) then
#pal                 xarg = sqrt(intsum(i))
#pal                 if(xarg.gt.0.) then
#pal                   intsig(i) = intdif(i)/xarg
#pal                 else
#pal                   intsig(i) = 0.
#pal                 endif
#pal               else
#pal                 intsig(i) = 0.
#pal               endif
#pal             enddo
#pal    20       continue 
#pal *
#pal             results(5) = xonmax*1.3
#pal             results(6) = xonmax*1.24
#pal             results(7) = xonmax*1.18
#pal             results(8) = xonmax*1.12
#pal             results(9) = xonmax*1.06
#pal             results(10) = xonmax*1.00
#pal             end
#pal             call loop
#pal             end
#pal     QUIT
#pal * 
#pal ymax=results(5)                    | Scale y-axis of plots
#pal h/set/maximum 1 [ymax]
#pal h/set/minimum 1 0.0
#pal h/set/maximum 2 [ymax]
#pal h/set/minimum 2 0.0
#pal *
#pal * PLOT 1
#pal *
#pal * TEMPORARY! comment out because too many IFs!
#pal * IF [fpicts].eq.1 THEN
#pal *   pict/create alpic
#pal * ENDIF
#pal *** First plot on with off shown as dashed histo
#pal h/pl 1  ; set dmod 1 k
#pal h/pl 1 pes 1
#pal set dmod 2
#pal h/pl 2 s
#pal set dmod 1
#pal atitle 'Alpha "M#deg"N#' ' '
#pal set xlab 1.2
#pal atitle '' 'Events per 5 degree'
#pal IF [fpicts].eq.1 THEN
#pal *  pict/file 10 [source].apic ! N
#pal *  pict/izout alpic
#pal *  close 10
#pal    pict/print [source]al.eps
#pal    pict/delete alpic
#pal ENDIF
#pal * set xlab 0.5
#pal *
#pal *** Draw box with excess and significance
#pal xexp=results(1)        | ON-OFF per minute         
#pal xsigp=results(2)       | Significance per pair
#pal xext=results(3)        | ON-OFF total excess for all pairs
#pal xsigt=results(4)       | Total significance for all pairs
#pal xexta=results(11)      | ON-OFF for alpha analysis, total
#pal xsigta=results(12)     | Significance for alpha analysis, total
#pal xexpa=results(13)      | ON-OFF per minute for alpha analysis
#pal xsigpa=results(14)     | Significance for alpha analysis, per run
#pal * 
#pal y1=results(10)
#pal y2=results(5)
#pal y1=results(6)
#pal y2=results(7)
#pal y3=results(8)
#pal y4=results(9)
#pal * BOX 40 90 [y1] [y2]
#pal * 
#pal * if [inoff].eq.[inon] then    | Only do on off if num on/off runs match
#pal *   text 65 [y1] 'Excess"J# '//[xexp]//' [g]/min' 0.2 ! c
#pal *   text 65 [y2] 'Sig"J# '//[xsigp]//' [s]/pair' 0.2 ! c
#pal *   text 65 [y3] 'Total Excess"J# '//[xext]//' [g]' 0.2 ! c
#pal *   text 65 [y4] 'Total Sig"J# '//[xsigt]//' [s]' 0.2 ! c
#pal * else                     | Otherwise do alpha analysis
#pal *   text 65 [y1] 'Excess"J# '//[xexpa]//' [g]/min' 0.2 ! c
#pal *   text 65 [y2] 'Sig"J# '//[xsigpa]//' [s]/pair' 0.2 ! c
#pal *   text 65 [y3] 'Total Excess"J# '//[xexta]//' [g]' 0.2 ! c
#pal *   text 65 [y4] 'Total Sig"J# '//[xsigta]//' [s]' 0.2 ! c
#pal * endif
#pal * 
#pal h/set/maximum 1 [ymax]
#pal h/set/minimum 1 0.0
#pal h/set/maximum 2 [ymax]
#pal h/set/minimum 2 0.0
#pal * 
#pal h/put/cont 70 intdif       | Put contents of vector xx into histogram 70
#pal h/put/cont 80 intsig
#pal * 
#pal |*** Plot the difference between on and off as a histogram
#pal |h/pl 50
#pal |atitle 'Alpha (deg)' ' '
#pal |set dmod 2
#pal |line 0.0 0.0 90.0 0.0
#pal |set dmod 1
#pal * 
#pal |*** Plot the integral excess histogram 
#pal |h/pl 70
#pal |set dmod 2
#pal |line 0.0 0.0 90.0 0.0
#pal |set dmod 1
#pal *
#pal * PLOT 2
#pal *
#pal * Calculate Li and Ma significance, Helene upper limits
#pal *
#pal call [comisdir]ulcomis.f
#pal *** Plot the integral significance histogram
#pal zon 2 3 2 s
#pal nul 0 16 0 14 AB
#pal text 1 14 'Total Duration   "J# '//$eval(tdurcut(1))//' seconds.           '_
#pal   0.25 ! l
#pal text 1 13 'TRACKING ANALYSIS "J#' 0.25 ! l
#pal text 1 12.6 '-------------' 0.25 ! l
#pal text 1 12 'ON "J# '//[cut7]//' Events"J# '//$eval(stats(1,7)) _
#pal   0.25 ! l
#pal text 1 11 'OFF"J# '//[cut8]//' Events"J# '//$eval(stats(1,8)) _
#pal   0.25 ! l
#pal text 1 10 'OFF/ON Ratio     "J# '//$eval(roffon(1)) 0.25 ! l
#pal tmpval=$format($eval(sigtr(1)),f6.2)
#pal text 1 9 'Significance"J# '//[tmpval]//' [s]' 0.25 ! l
#pal sigtmp = $eval(sigtr(1))
#pal IF [sigtmp] > 0.0 THEN
#pal   tmpval = $format($eval(ratetr(1)),f7.3)
#pal   tmppm = $format($sigma(ratetr(1)/sigtr(1)),f7.3)
#pal   text 1 8 _
#pal 'Rate"J#  '//[tmpval]//'"a#'//[tmppm]//' [g]/min' 0.25 ! l
#pal   tmpval=$format($eval(fluxtr(1)),f9.3)
#pal   tmppm=$format($sigma(fluxtr(1)/sigtr(1)),f7.3) 
#pal   text 1 7 _
#pal 'Flux"J# '//[tmpval]//'"a#'//[tmppm]//'"X#10^-12!cm^-2!s^-1!' 0.25 ! l
#pal ENDIF
#pal tmpval = $format($eval(ultr(1)),f7.3)
#pal text 1 6  'Rate u.l."J# '//[tmpval]//' [g]/min' 0.25 ! l
#pal tmpval = $format($eval(ulfltr(1)),f9.3)
#pal text 1 5 'Flux u.l."J# '//[tmpval]//'"X#10^-12!cm^-2!s^-1!' 0.25 ! l
#pal *
#pal IF [inon].eq.[inoff] THEN
#pal   text 1 4 'ON/OFF ANALYSIS "J#' 0.25 ! l
#pal   text 1 3.6 '------------' 0.25 ! l
#pal   tmpval=$format($eval(sigoo(1)),f6.2)
#pal   text 1 3 'Significance"J# '//[tmpval]//' [s]' 0.25 ! l
#pal   sigtmp = $eval(sigoo(1))
#pal   IF [sigtmp] > 0.0 THEN
#pal     tmpval = $format($eval(rateoo(1)),f7.3)
#pal     tmppm = $format($sigma(rateoo(1)/sigoo(1)),f7.3)
#pal     text 1 2 _
#pal 'Rate"J#  '//[tmpval]//'"a#'//[tmppm]//' [g]/min' 0.25 ! l
#pal     tmpval=$format($eval(fluxoo(1)),f9.3)
#pal     tmppm=$format($sigma(fluxoo(1)/sigoo(1)),f7.3) 
#pal     text 1 1 _
#pal 'Flux"J# '//[tmpval]//'"a#'//[tmppm]//'"X#10^-12!cm^-2!s^-1!' 0.25 ! l
#pal   ENDIF
#pal   tmpval = $format($eval(uloo(1)),f7.3)
#pal   text 1 0  'Rate u.l."J# '//[tmpval]//' [g]/min' 0.25 ! l
#pal   tmpval = $format($eval(ulfloo(1)),f9.3)
#pal   text 1 -1 'Flux u.l."J# '//[tmpval]//'"X#10^-12!cm^-2!s^-1!' 0.25 ! l
#pal ENDIF
#pal *
#pal * PLOT 3
#pal *
#pal IF ([#] > 2).and.([fex2d].eq.0) THEN
#pal   IF [inon].eq.[inoff] THEN
#pal *   nul 0 16 0 16 AB
#pal *mac    exec alphatot#whipcam [ntb] [dbdirw] [xmin] [xmax] dped xr yr
#pal     exec alphatot#whipcam [ntb] [dbdirw] [xmin] [xmax] dped
#pal   ELSE
#pal     vec/cr pedflat(700) r
#pal     vec/read pedflat [dbdir]pedflat.vec
#pal     *mac nbt = $VLEN(pedflat)
#pal     *mac v/cr ntp(1) r [nbt]
#pal     *mac v/pr ntp
#pal APPLIcatio COMIS QUIT
#pal       subroutine pedsub()
#pal 
#pal       vector pedvar,pedflat,npmt
#pal       integer i,np
#pal 
#pal       np=npmt(1)
#pal      
#pal       do i=1,np
#pal         pedvar(i)=(pedvar(i)*pedvar(i)-pedflat(i)*pedflat(i))
#pal         if pedvar(i).ge.0.0 then
#pal           pedvar(i)=sqrt(pedvar(i))
#pal         else
#pal           pedvar(i) = -1.0*sqrt(-1.0*pedvar(i))
#pal         endif
#pal       enddo
#pal       return
#pal       end
#pal       call pedsub
#pal       end
#pal QUIT
#pal *   nul 0 16 0 16 AB
#pal *mac    exec alphatot#whipcam [ntb] xr yr pedvar
#pal     exec alphatot#whipcam [ntb] [dbdirw] [xmin] [xmax] pedvar
#pal   ENDIF
#pal   atitle 'Stars ([D]pedvar)    X"M#deg"N#' 'Y"M#deg"N#'
#pal ELSE
#pal   nul 0 16 0 16 AB
#pal ENDIF
#pal *
#pal * PLOT 4
#pal *
#pal IF ([chmode].eq.0).or.([fsig2d].eq.1) THEN | Do 2-d plot if chain is explicit
#pal *
#pal * First plot excess contours
#pal *
#pal   hist/put/cont 16 difmesh
#pal   IF [fex2d].eq.1 THEN
#pal     zon 2 3 3 s
#pal     IF [fcolor].eq.1 THEN
#pal       igset ncol 40
#pal       palette 1
#pal     ELSE
#pal       igset ncol 40
#pal       palette 1
#pal       igset ncol 40
#pal     ENDIF
#pal     IF [fupo2d].eq.0 THEN
#pal *     surf 16 90 0 2
#pal       contour 16 [nlevel] 3
#pal       atitle 'Excess at X"M#deg"N#' 'Y"M#deg"N#' 
#pal     ELSE
#pal *     hist/op/sub 17 18 17
#pal       hist/put/cont 17 difupo
#pal       hist/put/cont 18 sigupo
#pal       contour 17 18 3
#pal * MAC 990628 - make text not be tied to size of FoV
#pal       null 0. 15. 0. 15. ABS
#pal       minex = $HINFO(17,'MIN')
#pal       maxex = $HINFO(17,'MAX')
#pal *      IF [fbare].eq.0 THEN
#pal *        text 1.6 -0.4 'Excess"J# ' 0.18 ! l
#pal *        text 1.6 -0.6 [minex]//'[g]' 0.20 ! l
#pal *        text 1.6 -0.8 [maxex]//'[g]' 0.20 ! l
#pal         text 15.5 5.5 'Excess"J# ' 0.18 ! l
#pal         text 15.5 4.5 [minex]//'[g]' 0.20 ! l
#pal         text 15.5 3.5 [maxex]//'[g]' 0.20 ! l
#pal *      ENDIF
#pal       minex = $HINFO(18,'MIN')
#pal       maxex = $HINFO(18,'MAX')
#pal       minex=$format([minex],f6.2)
#pal       maxex=$format([maxex],f6.2)
#pal *      IF [fbare].eq.0 THEN
#pal *        text 1.6 -1.0 'Significance"J# ' 0.18 ! l
#pal *        text 1.6 -1.2 [minex]//'[s]' 0.20 ! l
#pal *        text 1.6 -1.4 [maxex]//'[s]' 0.20 ! l
#pal         text 15.5 2.5 'Significance"J# ' 0.18 ! l
#pal         text 15.5 1.5 [minex]//'[s]' 0.20 ! l
#pal         text 15.5 0.5 [maxex]//'[s]' 0.20 ! l
#pal *      ENDIF
#pal       atitle 'Excess at X"M#deg"N#' 'Y"M#deg"N#' 
#pal     ENDIF   
#pal   ENDIF
#pal *
#pal   IF [fpicts].eq.1 THEN
#pal     pict/create mespic
#pal   ENDIF
#pal *
#pal * TEMPORARY!!!
#pal   sigma sigmesh=sigmesh+0.001
#pal   hist/put/cont 15 sigmesh
#pal   IF [fshcon].eq.1 THEN
#pal * IF ([fex2d].eq.1).and.([fshcon].eq.1) THEN
#pal     zon 2 3 4 s
#pal     IF [fcolor].eq.1 THEN
#pal       igset ncol 40
#pal       palette 1
#pal     ELSE
#pal       igset ncol 40
#pal       palette 1
#pal       igset ncol 40
#pal     ENDIF
#pal *
#pal * Added 951011 to scale to [maxsig]
#pal *   
#pal     maxs = $HINFO(15,'MAX')
#pal     snlev = [maxs]/[maxsig]
#pal     snlev = [snlev]*[nlevel]
#pal *
#pal * Comment out this line if you want to use full range of grayscale
#pal *   contour 16 [snlev] 3
#pal     contour 16 [nlevel] 3
#pal *   atitle 'Excess at X"M#deg"N#' 'Y"M#deg"N#' 
#pal   ENDIF
#pal   zon 2 3 4 s
#pal   contour 15 ! 2 clevel
#pal ELSE
#pal   nul [xmin] [xmax] [ymin] [ymax] AB
#pal ENDIF
#pal *
#pal * Get RA and DEC from a file, find bright stars in the
#pal * vicinity
#pal *
#pal for/file 20 [ffile]//.hdr
#pal for/file 21 [comisdir]pawbs.db
#pal APPLIcation COMIS QUIT 
#pal       subroutine gradec
#pal 
#pal       vector       fra,fdec,favel
#pal       vector       futdat,fmjd,fsigtr,favetr
#pal       vector    rafmt,decfmt
#pal       vector       xbs,ybs,mbs,nbs
#pal *
#pal       character    cline*80
#pal       real ra,dec
#pal       integer      utdate
#pal       real mjd,srate,sigtr,avetr
#pal       real hh,mm,ss,radeg,dd,arcmm,arcss,decdeg 
#pal       real      ratmp,dectmp,magtmp
#pal       real aveel
#pal       integer   nstars
#pal       integer      i,j
#pal       real denom
#pal *
#pal       cline='                                        '
#pal       do while (cline(1:4) .ne. 'date')
#pal         cline='                                        '
#pal         read(20,100,end=99)cline
#pal       end do
#pal       read(cline(15:30),*)utdate
#pal       do while (cline(1:2) .ne. 'ra')
#pal         cline='                                        '
#pal         read(20,100,end=99)cline
#pal       end do
#pal       read(cline(15:30),*)ra
#pal       do while (cline(1:3) .ne. 'dec')
#pal         cline='                                        '
#pal         read(20,100,end=99)cline
#pal       end do
#pal       read(cline(15:30),*)dec
#pal       do while (cline(1:3) .ne. 'ave')
#pal         cline='                                        '
#pal         read(20,100,end=99)cline
#pal       end do
#pal       read(cline(15:30),*)aveel
#pal       do while (cline(1:7) .ne. 'mean_tr')
#pal         cline='                                        '
#pal         read(20,100,end=99)cline
#pal       end do
#pal       read(cline(15:30),*)avetr
#pal       do while (cline(1:6) .ne. 'rms_tr')
#pal         cline='                                        '
#pal         read(20,100,end=99)cline
#pal       end do
#pal       read(cline(15:30),*)sigtr
#pal       do while (cline(1:7) .ne. 'gps_mjd')
#pal         cline='                                        '
#pal         read(20,100,end=99)cline
#pal       end do
#pal       read(cline(15:30),*)mjd
#pal *
#pal       rafmt(1) = ra        ! Formatted ra: hhmmss.s
#pal       decfmt(1) = dec      ! Formatted dec: ddmmss.s
#pal *
#pal *     write(*,*)'ra,dec:',ra,dec
#pal       hh=aint(ra/10000.)
#pal       mm=aint((ra-hh*10000)/100.)
#pal       ss=ra-hh*10000-mm*100.
#pal       radeg=(hh+mm/60.+ss/3600.)*15.0
#pal *
#pal       dd=aint(dec/10000.)
#pal       arcmm=aint((dec-dd*10000.)/100.)
#pal       arcss=dec-dd*10000.-arcmm*100.
#pal       decdeg=dd+arcmm/60.0+arcss/3600.
#pal *
#pal *     write(*,*)'radeg,decdeg:',radeg,decdeg
#pal *
#pal       ra = radeg/57.29577951
#pal       dec = decdeg/57.29577951
#pal *
#pal       fra(1) = ra
#pal       fdec(1) = dec
#pal       favel(1) = aveel
#pal       favetr(1) = avetr
#pal       fsigtr(1) = sigtr
#pal       futdat(1) = utdate
#pal       fmjd(1) = mjd
#pal *
#pal       j=1
#pal       do i=1,1500
#pal         read(21,*,end=55)ratmp,dectmp,magtmp
#pal         if(abs(dectmp-decdeg).lt.2.0) then
#pal           dectmp=dectmp/57.29577951
#pal           ratmp=ratmp/57.29577951
#pal           denom = sin(dec)*sin(dectmp)+cos(dec)*cos(dectmp)*
#pal      &            cos(ratmp-ra)
#pal           if(denom.gt.0.0) then
#pal             xbs(j)=57.29577951*cos(dectmp)*sin(ratmp-ra)/denom
#pal             ybs(j)=57.29577951*(cos(dec)*sin(dectmp)-
#pal      &             sin(dec)*cos(dectmp)*cos(ratmp-ra))/denom
#pal *           write(*,*)'ra,dec,mag: ',ratmp,dectmp,magtmp
#pal *           write(*,*)'xbs,ybs: ',xbs(j),ybs(j)
#pal             if((xbs(j).gt.-2.4).and.(xbs(j).lt.2.4).and.
#pal      &         (ybs(j).gt.-2.4).and.(ybs(j).lt.2.4)) then
#pal               mbs(j)=7.0-magtmp
#pal               if(mbs(j).gt.0.0) then
#pal                 write(*,*)'Found star in field at: (',xbs(j),',',
#pal      &             ybs(j),')'
#pal                 j=j+1
#pal                 if(j.gt.100) goto 55
#pal               endif
#pal             endif
#pal           endif
#pal         endif
#pal       enddo
#pal 55    nbs(1)=j
#pal 99    continue
#pal 100   format(a)
#pal       return
#pal       end
#pal       call gradec
#pal       end
#pal QUIT
#pal close 21
#pal close 20
#pal *
#pal * Text write ups
#pal *
#pal null 0 15 0 15 ABS
#pal IF ([chmode].eq.0).or.([fsig2d].eq.1) THEN | Do 2-d text 
#pal   minex = $HINFO(16,'MIN')
#pal   maxex = $HINFO(16,'MAX')
#pal   IF [fbare].eq.0 THEN
#pal     atitle 'Significance at X"M#deg"N#' 'Y"M#deg"N#'
#pal     text 15.5 5.5 'Excess"J# ' 0.18 ! l
#pal     text 15.5 4.5 [minex]//'[g]' 0.20 ! l
#pal     text 15.5 3.5 [maxex]//'[g]' 0.20 ! l
#pal   ELSE
#pal     atitle 'X"M#deg"N#' 'Y"M#deg"N#'
#pal   ENDIF
#pal   minex = $HINFO(15,'MIN')
#pal   maxex = $HINFO(15,'MAX')
#pal   minex=$format([minex],f6.2)
#pal   maxex=$format([maxex],f6.2)
#pal   IF [fbare].eq.0 THEN
#pal     text 15.5 2.5 'Significance"J# ' 0.18 ! l
#pal     text 15.5 1.5 [minex]//'[s]' 0.20 ! l
#pal     text 15.5 0.5 [maxex]//'[s]' 0.20 ! l
#pal   ENDIF
#pal ENDIF
#pal nstars = $eval(nbs(1))
#pal nstars = [nstars]-1
#pal xra = $format($eval(rafmt),f8.1)
#pal xdec = $format($eval(decfmt),f9.1)
#pal aetmp = $format($eval(favel(1)),f7.2)
#pal IF [fpicts].eq.0 THEN
#pal   text 0. 16.5 'Average Elevation"J# '//[aetmp] 0.25 ! l
#pal ENDIF
#pal * IF [fbare].eq.0 THEN
#pal  text 0. 15.5 _
#pal  [source]//' RA"J# '//[xra]//', DEC"J# '//[xdec] 0.25 ! l
#pal * ENDIF
#pal IF ([chmode].eq.0).or.([fsig2d].eq.1) THEN | Do 2-d plot if chain is explicit
#pal  IF [fbare].eq.0 THEN
#pal   set mtyp 20
#pal   IF [flstar].eq.1 THEN
#pal     vec/op/vscale xbs -1.0 xbs
#pal   ENDIF
#pal   DO i=1,[nstars]
#pal     scale = $eval(mbs([i]))
#pal     scale = 0.3+[scale]*0.25
#pal     set mscf [scale]
#pal     graph 1 xbs([i]) ybs([i]) 'p'
#pal     message 'Star '//[i]//': '//$eval(xbs([i]))//','//$eval(ybs([i]))
#pal   ENDDO
#pal   text 15.5 14.5 'Mag.' 0.25 ! l
#pal   set mtyp 20
#pal   vec/cr ykey(6) r 13. 11.75 10.5 9.25 8. 6.75
#pal   txtdpt = 0.2666
#pal   text 15.5 $eval(ykey(1)) '"0#' (0.3+6*0.25)*[txtdpt] ! l
#pal   text 16.75 $eval(ykey(1)) '1' 0.25 ! l
#pal   text 15.5 $eval(ykey(2)) '"0#' (0.3+5*0.25)*[txtdpt] ! l
#pal   text 16.75 $eval(ykey(2)) '2' 0.25 ! l
#pal   text 15.5 $eval(ykey(3)) '"0#' (0.3+4*0.25)*[txtdpt] ! l
#pal   text 16.75 $eval(ykey(3)) '3' 0.25 ! l
#pal   text 15.5 $eval(ykey(4)) '"0#' (0.3+3*0.25)*[txtdpt] ! l
#pal   text 16.75 $eval(ykey(4)) '4' 0.25 ! l
#pal   text 15.5 $eval(ykey(5)) '"0#' (0.3+2*0.25)*[txtdpt] ! l
#pal   text 16.75 $eval(ykey(5)) '5' 0.25 ! l
#pal   text 15.5 $eval(ykey(6)) '"0#' (0.3+1*0.25)*[txtdpt] ! l
#pal   text 16.75 $eval(ykey(6)) '6' 0.25 ! l
#pal  ENDIF     | end fbare
#pal *
#pal * Now plot RA and DEC contours
#pal *
#pal   RA = $eval(fra(1))
#pal   DEC = $eval(fdec(1))
#pal * RA = 89.7311/57.29577951
#pal * DEC = 23.0080/57.29577951
#pal   XLO = -2.4/57.29577951
#pal   XHI = 2.4/57.29577951
#pal   func/fun2 25 atan(((sin([DEC])+y*cos([DEC]))/(cos([DEC])-y*sin([DEC])))*cos(atan(x/(cos([DEC])-y*sin([DEC]))))) 60 [XLO] [XHI] 60 _
#pal     [XLO] [XHI] ' '
#pal   func/fun2 26 [RA]+atan(x/(cos([DEC])-y*sin([DEC]))) 60 [XLO] [XHI] 60 _
#pal     [XLO] [XHI] ' '
#pal *
#pal * Create vector of 0.3deg offsets in RA or DEC
#pal *
#pal   vec/create offset(17) R -0.05585 -0.04887 -0.04189 -0.03491 -0.02793 _
#pal  -0.02094 -0.01396 -0.00698 0.0 0.00698 0.01396 0.02094 0.02793 0.03491 _
#pal  0.04189 0.04887 0.05585
#pal   vec/create allalpha(17) R 17*[RA]
#pal   vec/create alldec(17) R 17*[DEC]
#pal   vec/op/vadd offset alldec cdec
#pal   vec/op/vadd offset allalpha calpha
#pal   DO i=1,17
#pal     tmpvar = $eval(cdec([i]))
#pal     maxa = $HINFO(25,'MAX')
#pal     mina = $HINFO(25,'MIN')
#pal     maxb = $HINFO(26,'MAX')
#pal     minb = $HINFO(26,'MIN')
#pal 
#pal     IF [tmpvar] < [maxa] THEN
#pal       tmpvar = $eval(cdec([i]))
#pal       IF [tmpvar] > [mina] THEN
#pal         contour 25 ! 2S cdec([i]:[i])
#pal       ENDIF
#pal     ENDIF
#pal     tmpvar = $eval(calpha([i]))
#pal     IF [tmpvar] < [maxb] THEN
#pal       tmpvar = $eval(calpha([i]))
#pal       IF [tmpvar] > [minb] THEN
#pal         contour 26 ! 2S calpha([i]:[i])
#pal       ENDIF
#pal     ENDIF
#pal   ENDDO
#pal * TEMPORARY! comment out because too many IFs!
#pal * set XSIZ 0
#pal * set YSIZ 0
#pal * IF [fpicts].eq.1 THEN
#pal *   pict/print [source]m.eps
#pal *   pict/delete mespic
#pal * ENDIF
#pal ELSE                       | Do rate plots only if chain given on command
#pal                    | line, and if only one on/off pair is
#pal                    | given.
#pal * zone 2 4 7 s
#pal   set mtyp 0
#pal   IF [np].eq.1 THEN
#pal     dur1=durs(1)
#pal     1d 90 ' ' 30 0. 1800.           | ON Raw rate  
#pal     1d 95 ' ' 30 0. 1800.           | OFF Raw rate
#pal     cd //allon
#pal     nt/proj 90 100.t10phase t10livetime.lt.[dur1]
#pal     cd //allof
#pal     nt/proj 95 100.t10phase t10livetime.lt.[dur1]
#pal *   zon 2 4 07 's'
#pal     IF [inon].eq.[inoff] THEN
#pal       zon 2 6 6 s
#pal     ELSE
#pal       zon 2 3 4 s
#pal     ENDIF
#pal     hi/plot 90 ' '
#pal     hi/plot 90 'es'
#pal     atitle 'ON- Raw Rate ' ' '
#pal     IF [inon].eq.[inoff] THEN
#pal       zon 2 6 8 s
#pal       hi/plot 95 ' '
#pal       hi/plot 95 'es'
#pal       zon 2 3 5 s
#pal       atitle 'OFF- Raw Rate' ' '
#pal     ENDIF
#pal   ELSE
#pal *   set XSIZ 20
#pal *   set YSIZ 40
#pal     hist/put/cont 15 sigmesh
#pal     contour 15 ! 2 clevel
#pal *   set XSIZ 0
#pal *   set YSIZ 0
#pal   ENDIF
#pal ENDIF
#pal * 
#pal opt linx 
#pal opt nsta
#pal *
#pal |v/print on
#pal |v/print results
#pal |v/print ontime
#pal *
#pal * nul 0 16 1 13 AB
#pal nul 0 16 -3 12 AB
#pal *
#pal |call [comisdir]calc_sigs.f
#pal *
#pal ron=stats(1,1)
#pal roff=stats(2,1)
#pal rs=sigmas(1)
#pal *
#pal nbron=stats(1,2)
#pal nbroff=stats(2,2)
#pal nbrsig=sigmas(2)
#pal *
#pal ton=stats(1,3)
#pal toff=stats(2,3)
#pal ts=sigmas(3)
#pal *
#pal son=stats(1,4)
#pal soff=stats(2,4)
#pal ss=sigmas(4)
#pal *
#pal sn2090=stats(1,5)
#pal sf2090=stats(2,5)
#pal ss2090=sigmas(5)
#pal *
#pal oon=stats(1,6)
#pal ooff=stats(2,6)
#pal os=sigmas(6)
#pal *
#pal bon=stats(1,7)
#pal boff=stats(2,7)
#pal *
#pal rs=$substring([rs],1,7)
#pal nbrsig=$substring([nbrsig],1,7)
#pal ts=$substring([ts],1,7)
#pal os=$substring([os],1,7)
#pal ss=$substring([ss],1,7)
#pal ss2090=$substring([ss2090],1,7)
#pal xsigt=$substring([xsigt],1,7)
#pal *
#pal text 4 12.25 'RAW' 0.2 ! l
#pal text 9 12.25 'NBR3' 0.2 ! l
#pal text 14 12.25 'TRIGGER' 0.2 ! l
#pal text 19 12.25 'SHAPE' 0.2 ! l
#pal text 23 12.25 'OFF-ALPHA' 0.2 ! l
#pal text 29 12.25 'ORIENT' 0.2 ! l
#pal text 34 12.25 'BOTH' 0.2 ! l
#pal text 0 10.75 'ON' 0.2 ! l
#pal IF [inon].eq.[inoff] THEN
#pal   text 0 10 'OFF' 0.2 ! l
#pal   text 0 8.5 'EXCESS' 0.2 ! l
#pal ENDIF
#pal line='------------------------------------------------------------------'   
#pal text 0 13 [line] 0.2 ! l
#pal text 0 11.5 [line] 0.2 ! l
#pal text 4 10.75 [ron] 0.2 ! l
#pal text 9 10.75 [nbron] 0.2 ! l
#pal text 14 10.75 [ton] 0.2 ! l
#pal text 19 10.75 [son] 0.2 ! l
#pal text 24 10.75 [sn2090] 0.2 ! l
#pal text 29 10.75 [oon] 0.2 ! l
#pal text 34 10.75 [bon] 0.2 ! l
#pal text 0 9.25 [line] 0.2 ! l
#pal IF [inon].eq.[inoff] THEN
#pal   text 4 10 [roff] 0.2 ! l
#pal   text 4 8.5 [rs] 0.2 ! l
#pal   text 9 10 [nbroff] 0.2 ! l
#pal   text 9 8.5 [nbrsig] 0.2 ! l
#pal   text 14 10 [toff] 0.2 ! l
#pal   text 14 8.5 [ts] 0.2 ! l
#pal   text 19 10 [soff] 0.2 ! l
#pal   text 19 8.5 [ss] 0.2 ! l
#pal   text 24 10 [sf2090] 0.2 ! l
#pal   text 24 8.5  [ss2090] 0.2 ! l
#pal   text 29 10 [ooff] 0.2 ! l
#pal   text 29 8.5 [os] 0.2 ! l
#pal   text 34 10 [boff] 0.2 ! l
#pal   text 34 8.5 [xsigt] 0.2 ! l
#pal ENDIF
#pal *
#pal * IF [inon].eq.[inoff] THEN
#pal *   gpm=$format([xexp],f6.3)
#pal *   gpmr=[xexp]/[xsigt]
#pal *   gpmrate=$format([gpmr],f6.3)
#pal *   text 1 6 'Total Duration '//$eval(tdurcut(1))//' seconds.           '_
#pal * //[g]//' rate '//[gpm]//"a#//[gpmrate]//' per minute' 0.25 ! l
#pal * ELSE
#pal *   gpm=$format([xexpa],f6.3)
#pal *   gpmr=[xexpa]/[xsigta]
#pal * ENDIF 
#pal *
#pal * text 1 6 'Total Duration '//$eval(tdurcut(1))//' seconds.           '_
#pal * //[g]//' rate '//[xexp]//' per minute' 0.25 ! l
#pal *
#pal * nul 0 16 0 10 AB
#pal text 0 7.1 'Cuts"J# ' 0.23 ! l
#pal text 0 6.2 [cut1] 0.23 ! 1
#pal text 0 5.3 [cut2] 0.23 ! l
#pal text 0 4.4 [cut3] 0.23 ! l
#pal text 0 3.5 [cut4] 0.23 ! l
#pal text 0 2.6 [cut5] 0.23 ! l
#pal text 0 1.7 [cut6] 0.23 ! l
#pal text 0 0.8 [cut7] 0.23 ! l
#pal text 0 -0.1 [cut9] 0.23 ! l
#pal text 0 -1.0 [cut10] 0.23 ! l
#pal *
#pal zon 2 3 5 s
#pal nul 0 16 0 16 AB
#pal text -4 1 'Alpha ON "J#' 0.17 ! l
#pal IF [inon].eq.[inoff] THEN
#pal   text -4 -2 'Alpha OFF "J#' 0.17 ! l
#pal ENDIF
#pal |text 1 2.8 'Integral ' 0.25 ! l
#pal do i=1,6
#pal *   alphatxton=on([i])
#pal *   text 5*[i]+3 5 [alphatxton] 0.25 ! 1
#pal *   alphatxton=on([i]+6)
#pal *   text 5*[i]+3 4 [alphatxton] 0.25 ! 1
#pal *   alphatxton=on([i]+12)
#pal *   text 5*[i]+3 3 [alphatxton] 0.25 ! 1
#pal     alphatxton=on([i])
#pal     text 3*[i]-2 1 [alphatxton] 0.17 ! 1
#pal     alphatxton=on([i]+6)
#pal     text 3*[i]-2 0 [alphatxton] 0.17 ! 1
#pal     alphatxton=on([i]+12)
#pal     text 3*[i]-2 -1 [alphatxton] 0.17 ! 1
#pal *
#pal     IF [inon].eq.[inoff] THEN
#pal *     alphatxtoff=off([i])
#pal *     text 5*[i]+3 2 [alphatxtoff] 0.25 ! 1
#pal *     alphatxtoff=off([i]+6)
#pal *     text 5*[i]+3 1 [alphatxtoff] 0.25 ! 1
#pal *     alphatxtoff=off([i]+12)
#pal *     text 5*[i]+3 0 [alphatxtoff] 0.25 ! 1
#pal       alphatxtoff=off([i])
#pal       text 3*[i]-2 -2 [alphatxtoff] 0.17 ! 1
#pal       alphatxtoff=off([i]+6)
#pal       text 3*[i]-2 -3 [alphatxtoff] 0.17 ! 1
#pal       alphatxtoff=off([i]+12)
#pal       text 3*[i]-2 -4 [alphatxtoff] 0.17 ! 1
#pal     ENDIF
#pal enddo
#pal *
#pal set xwin 3.0
#pal IF [inon].eq.[inoff] THEN
#pal   zon 2 4 8 s
#pal   h/pl 80
#pal   atitle 'Alpha (deg)' 'Integral Sig. ([s])'
#pal   set dmod 2
#pal   line 0.0 0.0 90.0 0.0
#pal   set dmod 1
#pal ENDIF
#pal set xwin 2.0
#pal *
#pal * Now add some more text to the page
#pal *
#pal zon 2 3 2 s
#pal nul 0 16 0 14 AB
#pal tmpa = $format($eval(futdat(1)),f7.0)
#pal tmpb = $format($eval(fmjd(1)),f12.5)
#pal text 1 15 'UT Date "J# '//[tmpa]//' MJD "J# '//[tmpb] _
#pal   0.25 ! l
#pal IF [fex2d].eq.0 THEN
#pal   zon 2 3 3 s
#pal   nul -1.5 1.5 -1.5 1.5 AB
#pal   tmpa = $format($eval(favetr(1)),f7.3)
#pal   tmpb = $format($eval(fsigtr(1)),f7.3)
#pal   text -1.5 1.6 'Tracking Error "J# [m]='//[tmpa]//'   [s]='//[tmpb] _
#pal     0.25 ! l
#pal ENDIF
#pal IF [fpicts].eq.0 THEN
#pal   IF [chmode].eq.1 THEN
#pal     picture/print 'alpha_'//[ffile]//'x'//[inon]//'.ps' 
#pal   ELSE
#pal     picture/print alpha_total.ps
#pal   ENDIF
#pal   picture/del palph
#pal ENDIF
#pal *
#pal close 1
#pal close 2
#pal IF [fascii].eq.1 THEN
#pal   for/file 1 'cuton.tmp' 
#pal   for/file 2 'cutoff.tmp'
#pal * rewind 1
#pal * rewind 2
#pal   Message 'Generating ASCII output file....'
#pal   for/file 20 'pawtab.out'     |open equivalent of old tab.out for ascii
#pal                              |output of results.
#pal   call [comisdir]wrpawtab.f
#pal   message DONE
#pal   close 1
#pal   close 2
#pal   close 20
#pal ENDIF
#pal *
#pal * Write one row of a potential database file to tab.tmp.  Whether
#pal * this is actually appended to a database is up to the person running
#pal * alphatot.kumac.  Only the first on/off or tracking run goes into
#pal * the database, so mode=1 is recommended but not required.  
#pal *
#pal for/file 1 'cuton.tmp'     | Open tmp files which contain run numbers
#pal for/file 2 'cutoff.tmp' | to get around paw's string passing problems
#pal for/file 20 'tab.tmp'
#pal APPLIcation COMIS QUIT 
#pal       subroutine onetab
#pal 
#pal       vector futdat,fmjd,durs,favel
#pal       vector xaave,yaave   ! pedvar bright star position
#pal       vector ped
#pal       vector npmt
#pal       character*10 onfile,offfile
#pal       integer on(7),off(7)
#pal       integer utdate,onalon,onalof,ontrig
#pal       integer ofalon,ofalof,oftrig
#pal       integer np
#pal       real mjd,aveel,skyvar,rundur,peddev
#pal       real xstar,ystar
#pal       integer i
#pal       real maxped,minped
#pal 
#pal       read(1,200,end=50) onfile,(on(i),i=1,7)
#pal       read(2,200,end=50) offfile,(off(i),i=1,7)
#pal 
#pal  50   continue
#pal       np=npmt(1)
#pal       utdate=futdat(1) 
#pal       mjd = fmjd(1)
#pal       rundur = durs(1)     ! Cut-to duration of first pair
#pal       onalon = on(7)       ! ON-source, alpha on e.g. 0,15deg
#pal       onalof = on(5)       ! ON-source, alpha off e.g. 20,65deg
#pal       ontrig = on(3)
#pal       ofalon = off(7)
#pal       ofalof = off(5) 
#pal       oftrig = off(3)
#pal       aveel = favel(1)     ! Average elevation
#pal       skyvar = 0.0 ! TEMPORARY
#pal       xstar = xaave(1)
#pal       ystar = yaave(1)
#pal 
#pal       maxped = 0.0
#pal       minped = 1000.0
#pal       do i=1,np
#pal         if(ped(i).gt.0.0) then
#pal           if(ped(i).gt.maxped) maxped = ped(i)
#pal           if(ped(i).lt.minped) minped = ped(i)
#pal         endif
#pal       end do
#pal       peddev = maxped-minped
#pal 
#pal       write(20,210)utdate,onfile(3:6),offfile(3:6),mjd,rundur,
#pal      &             ontrig,oftrig,onalon,onalof,ofalon,ofalof,aveel,
#pal      &             xstar,ystar,peddev
#pal *      write(*,210)utdate,onfile(3:6),offfile(3:6),mjd,rundur,
#pal *     &             ontrig,oftrig,onalon,onalof,ofalon,ofalof,aveel,
#pal *     &             xstar,ystar,peddev
#pal 
#pal  200  format(a10,7(1x,i9))
#pal  210  format(i6,1x,2(a4,1x),f10.4,1x,f10.2,1x,6(i9,1x),f7.2,1x,
#pal      &      2(f6.3,1x),f6.1)
#pal       return
#pal       end
#pal       call onetab
#pal       end
#pal QUIT
#pal shell cat tab.tmp >> runtab.out            | Append to running table
#pal close 1
#pal close 2
#pal close 20
#pal *
#pal *mac ENDIF | End if on duration is greater than zero
#pal *
#pal CHAIN -allon
#pal chain -allof
#pal v/del *
#pal h/del 0
#pal close 0
#pal *
#pal end:
#pal return
#pal *
#pal *************************************************************
#pal *
#pal MACRO whipcam
#pal *
#pal *
#pal *  Usage: exec alphatot#whipcam ntb dbdirw mfield pfield [vec] [x y]  
#pal *
#pal *  Plot vector "vec" of ntb values on the default x,y
#pal *  tube coordinates (read from dbdirw) of the whipple camera on a 
#pal *  field stretching from mfield to pfield, or those specified
#pal *  by the vectors "x" and "y".  xaave,yaave vectors assumed
#pal *  to be defined globally which will
#pal *  contain the returned position of the centroid of the brightest spot
#pal *  in pedvar.  
#pal *
#pal * Set up a few things
#pal ntb = [1]
#pal *mac dbdirw='/usr/dbgt/'
#pal dbdirw=[2]
#pal pfield = [4]
#pal mfield = [3]
#pal *
#pal vec/create x([ntb]) R
#pal vec/create y([ntb]) R
#pal vec/create r([ntb]) R
#pal *
#pal vec/read x,y,r [dbdirw]whip10m.coords.[ntb]
#pal graphics/attrib/sfais 1
#pal graphics/attrib/sfaci 10
#pal graphics/attrib/sfaci 6
#pal null [mfield] [pfield] [mfield] [pfield]
#pal *
#pal if [#].eq.4 then
#pal   do i=1,[ntb]
#pal         graphics/primitives/arc x([i]) y([i]) $eval(r([i])) $eval(r([i]))
#pal         graphics/pr/text x([i]) y([i])-0.04 [i] .15 ! c
#pal   enddo
#pal else
#pal   if [#].gt.5 then
#pal     vec/del x
#pal     vec/del y
#pal     vec/create x([ntb]) R
#pal     vec/create y([ntb]) R
#pal     vec/copy [6] x
#pal *   vec/op/vscale x -1.0 x | Flip camera to give sky-view
#pal     vec/copy [7] y
#pal     vec/copy [5] adc
#pal    message 'Using x,y vectors from command line'
#pal   else
#pal     vec/copy  [5] adc
#pal   endif
#pal * vec/cre adcor([ntb]) r
#pal * vec/copy adc adcor
#pal   vec/copy adc(1:[ntb]) adcin
#pal   sigma dmax=vmax(adc)     | Find max adc value for all PMTs
#pal   sigma tnmax=lvmax(adcin)
#pal   imtmp=tnmax(1)
#pal   maxtmp=dmax(1)
#pal   vec/cr xasum(1) R 0.0
#pal   vec/cr yasum(1) R 0.0
#pal   vec/cr nasum(1) R 0.0
#pal   if [maxtmp] < 0.1 then
#pal     maxtmp = 0.1
#pal   else if [maxtmp] > 1.0e10 then
#pal     maxtmp = 0.1
#pal   endif
#pal   vec/op/vscale adc (0.124/[maxtmp]) adc
#pal   do i=1,[ntb]
#pal       tmp = adc([i])
#pal       if [tmp] > 0.0 then
#pal         sigma delx=(x([i])-x([imtmp]))
#pal         sigma dely=(y([i])-y([imtmp]))
#pal         sigma adist=delx*delx+dely*dely
#pal         tmp=adist(1)
#pal         if [tmp] < 0.36 then
#pal           sigma xasum = xasum+adc([i])*adc([i])*x([i])
#pal           sigma yasum = yasum+adc([i])*adc([i])*y([i])
#pal           sigma nasum = nasum+adc([i])*adc([i])
#pal         endif 
#pal         graphics/primitives/arc x([i]) y([i]) 0 adc([i])
#pal       else
#pal         graphics/primitives/arc x([i]) y([i]) adc([i]) adc([i])
#pal       endif
#pal       graphics/pr/arc x([i]) y([i]) $eval(r([i])) $eval(r([i]))
#pal *     graphics/pr/text x([i]) y([i])-0.04 [i] .15 ! c
#pal   enddo
#pal   tmp=nasum(1)
#pal   if [tmp] > 0.0 then
#pal     sigma xaave = xasum/nasum
#pal     sigma yaave = yasum/nasum
#pal     xstr = $format($eval(xaave(1)),f6.2)
#pal     ystr = $format($eval(yaave(1)),f6.2)
#pal     set mtyp 2
#pal     set mscf 2
#pal     graph 1 xaave(1) yaave(1) 'p'
#pal     null 0 10 0 10 ABS
#pal     if [maxtmp] > 2.0 then
#pal       graphics/pr/text 0.25 9.5 _
#pal 'Star at ('//[xstr]//','//[ystr]//')' .24 ! l
#pal     endif
#pal   endif  
#pal   tdmax=dmax(1)
#pal   txt='0 to '//[tdmax]
#pal   graphics/pr/text 9.75 9.5  [txt] .24 ! r
#pal endif
#pal *
#pal return
#pal 
#------------------------------------------------------------------------
#pql *
#pql * quicklook.kumac
#pql * JB
#pql * 950725
#pql *
#pql * PAW kumac to generate quick-look distributions for a chain of
#pql * files, including: peds, pedvars, gains, triggering tubes, delta-t
#pql * distributions, hillas parameter distributions, etc.
#pql *
#pql * Define options
#pql *
#pql dbdir = '/usr/dbgt/pgvec/'
#pql comisdir = '/usr/local/whipple/src/vpro/quicklook/'
#pql * Number of PMTs in camera and end of histograms
#pql *old ntb = 331
#pql *old maxh = 331.5
#pql ntb = 490
#pql maxh = 490.5
#pql *
#pql opt nbox             | no box around plot
#pql opt a4
#pql opt linx
#pql opt liny
#pql set mtyp 1           | marker type
#pql set xlab 1.3         | dist label to y-axis (default = 1.4)
#pql set ylab 0.6         | dist label to x-axis (default = 1.4)
#pql set xwin 1.9         | x-dist between plots (default = 2.0)
#pql set ywin 1.4         | y-dist between plots (default = 2.0)
#pql set asiz 0.22        | axis label size (default = 0.28)
#pql set XMGL 2.0         | Margins (defualt = 2.0)     
#pql set XMGR 1.0
#pql set YMGL 1.5
#pql set YMGU 2.1
#pql set VSIZ 0.18
#pql *
#pql * Initialize vectors
#pql *
#pql *
#pql v/cr hva(200) R
#pql v/cr hvb(200) R
#pql v/cr trig([ntb]) R
#pql *
#pql inon = 0
#pql inoff = 0
#pql ******************** MAC 990831
#pql IF [#] > 0 THEN
#pql   ffile = [1]
#pql ENDIF
#pql * The lines below get the dimensions of the 2D histograms for use in
#pql * defining the 2D histograms below.
#pql h/file 4 [ffile].h2d
#pql h/copy 11 111
#pql nx = $HINFO(111,'XBINS')
#pql nx2 = [nx]/2.
#pql v/cr nmx(2) r [nx] [nx2]
#pql ny = $HINFO(111,'YBINS')
#pql v/cr nmy(1) r [ny]
#pql ny2 = [ny]/2
#pql v/cr nmy(2) r [ny] [ny2]
#pql xmin = $HINFO(111,'XMIN')
#pql xmax = $HINFO(111,'XMAX')
#pql ymin = $HINFO(111,'YMIN')
#pql ymax = $HINFO(111,'YMAX')
#pql *MESS 'nx,ny = '//[nx]//','//[ny]
#pql *MESS 'xmin,xmax = '//[xmin]//','//[xmax]
#pql *MESS 'ymin,ymax = '//[ymin]//','//[ymax]
#pql h/del 111
#pql CLOSE 4
#pql ********************
#pql *
#pql * Build ntuple chain
#pql *
#pql CHAIN -
#pql IF [#] > 0 THEN
#pql   DO i=1,[#],1
#pql     CHAIN allon [%i].rz
#pql     inon = [inon] + 1
#pql   ENDDO
#pql   title 'Quicklook "J#'//[*]//' '//$DATE
#pql ELSE
#pql * exec qlchain.kumac
#pql   inon = non            | This is a way of using a scaler to pass
#pql                         | a variable to a macro, and return a var.
#pql   title 'Quicklook '//[inon]//' runs'//' '//$DATE
#pql ENDIF
#pql IF [inon] > 0 THEN
#pql   cd //allon
#pql   chain allon>
#pql ENDIF
#pql * IF [inon] > 0 THEN
#pql *   CHAIN
#pql *   CHAIN allon>
#pql *   CD allon
#pql * ENDIF
#pql *
#pql vec/create xr([ntb]) R
#pql vec/create yr([ntb]) R
#pql vec/create ped([ntb]) R
#pql vec/create pedvar([ntb]) R
#pql vec/create dped([ntb]) R
#pql vec/create gain([ntb]) R
#pql IF [inon].eq.1 THEN
#pql   vec/read xr,yr,ped,pedvar,dped,gain [dbdir]//[1].pgvec
#pql ENDIF
#pql *
#pql * General initializations
#pql *
#pql * zone 3 6 1
#pql zone 2 2 1
#pql * set HTYP -3
#pql *
#pql * Create Histograms
#pql *
#pql *** Triggering PMT ph dist
#pql hi/create/1dhisto 10 ' ' 100 0. 200.
#pql *** PMTs as max1
#pql hi/create/1dhisto 15 ' ' [ntb] 0.5 [maxh]
#pql *** PMTs as max2
#pql hi/create/1dhisto 16 ' ' [ntb] 0.5 [maxh]
#pql *** PMTs as max1 after cuts
#pql hi/create/1dhisto 17 ' ' [ntb] 0.5 [maxh]
#pql *** PMTs as max2 after cuts
#pql hi/create/1dhisto 18 ' ' [ntb] 0.5 [maxh]
#pql *** 2-d trigger rate plot after cuts
#pql hi/create/2dhisto 20 ' ' [nx] [xmin] [xmax] [ny] [ymin] [ymax]
#pql *old 2d 20 ' ' 41 -2.05 2.05 21 -2.1 2.1 0.
#pql *old 2d 20 ' ' 21 -1.3125 1.3125 11 -1.1375 1.1375 0.
#pql *** Events per minute vs. time
#pql hi/create/1dhisto 25 ' ' 35 0. 2100.
#pql *** Gammas per minute vs. time
#pql hi/create/1dhisto 30 ' ' 35 0. 2100.
#pql *** PMTs in images passing cuts
#pql hi/create/1dhisto 40 ' ' 31 -0.5 61.5
#pql *** Delta-t distribution
#pql hi/create/1dhisto 50 ' ' 50 0. 0.2
#pql *** Delta-t distribution
#pql hi/create/1dhisto 55 ' ' 10 0. 0.002
#pql *** Length
#pql hi/create/1dhisto 60 ' ' 40 0. 1.
#pql hi/create/1dhisto 61 ' ' 40 0. 1.
#pql hi/create/1dhisto 62 ' ' 40 0. 1.
#pql *** Width
#pql hi/create/1dhisto 63 ' ' 40 0. 1.
#pql hi/create/1dhisto 64 ' ' 40 0. 1.
#pql *** Dist
#pql hi/create/1dhisto 65 ' ' 40 0. 2.5
#pql hi/create/1dhisto 66 ' ' 40 0. 2.5
#pql *** Size
#pql hi/create/1dhisto 67 ' ' 200 10.0 5000.
#pql *** Size
#pql hi/create/1dhisto 68 ' ' 200 10.0 5000.
#pql *** Hadronicity
#pql hi/create/1dhisto 70 ' ' 40 0. 1.
#pql *** Hadronicity (supercuts)
#pql hi/create/1dhisto 75 ' ' 40 0. 1.
#pql *** Gain
#pql hi/create/1dhisto 80 ' ' 200 10. 1000.0
#pql *** Gain after supercuts
#pql hi/create/1dhisto 82 ' ' 20 10. 1000.0
#pql *** Gain after hadronicity cut
#pql hi/create/1dhisto 85 ' ' 20 10. 100.0
#pql *** Length/totsig
#pql hi/create/1dhisto 86 ' ' 40 0. 0.002
#pql *** Length/totsig after supercuts
#pql hi/create/1dhisto 87 ' ' 40 0. 0.002
#pql *** Length/totsig after muonicity cut
#pql hi/create/1dhisto 88 ' ' 40 0. 0.002
#pql *** Muon veto pulseheight
#pql hi/create/1dhisto 89 ' ' 500 1 2000
#pql *** Neighbor trigger
#pql hi/create/1dhisto 90 ' ' 4 0.5 4.5
#pql *** Neighbor trigger
#pql hi/create/1dhisto 95 ' ' 4 0.5 4.5
#pql *** Asymmetry
#pql hi/create/1dhisto 91 ' ' 41 -2.05 2.05
#pql *** Asymmetry after cuts
#pql hi/create/1dhisto 92 ' ' 41 -2.05 2.05
#pql *** Pedestals
#pql hi/create/1dhisto 96 ' ' [ntb] 0.5 [maxh]
#pql *** Pedestal Variances
#pql hi/create/1dhisto 97 ' ' [ntb] 0.5 [maxh]
#pql *** Gains
#pql hi/create/1dhisto 98 ' ' [ntb] 0.5 [maxh]
#pql *** 2-d
#pql *old 2d 99 ' ' 20 -2.5 2.5 20 -2.5 2.5 0.
#pql hist/cr/2dhist 99 ' ' [nx2] [xmin] [xmax] [ny2] [ymin] [ymax]
#pql *
#pql * Stuff Histograms using a selection function for speed
#pql * (thanks JQ!)
#pql *
#pql message 'Cutting ntuple...'
#pql nt/loop 100 [comisdir]//qluw.f
#pql message 'Done.'
#pql *
#pql switch Z
#pql pict/create QLPLOT
#pql *
#pql * Plot Histograms
#pql *
#pql *** Triggering PMT ph dist
#pql *pm 	hi/plot 10
#pql *pm 	atitle 'Triggering PMT PH Dist "M#d.c."N#'
#pql *
#pql *** PMTs in trigger
#pql *pm	hi/plot 15
#pql *pm	atitle 'Max1 Freq vs PMT' ' '
#pql *pm	v/cre max1numbers([ntb])
#pql *pm	get/cont 15 max1numbers
#pql *pm	v/write max1numbers max1.dat
#pql *pm	hi/plot 16
#pql *pm	atitle 'Max2 Freq vs PMT' ' '
#pql *pm	v/cre max2numbers([ntb])
#pql *pm	get/cont 16 max2numbers
#pql *pm	v/write max2numbers max2.dat
#pql *
#pql IF [inon].eq.1 THEN
#pql *** Pedestals
#pql   *pm	h/put/cont 96 ped
#pql   *pm	hi/plot 96 
#pql   *pm	atitle 'Pedestal vs PMT' ' '
#pql *
#pql *** Pedestal Variances
#pql   *pm	h/put/cont 97 pedvar
#pql   *pm	hi/plot 97
#pql   *pm	atitle 'Ped Variance vs PMT' ' '
#pql *
#pql *** Nitrogen Gain
#pql   *pm	h/put/cont 98 gain
#pql   *pm	hi/plot 98
#pql   *pm	atitle 'Nitrogen Gain vs PMT Number' ' '
#pql *
#pql *** 2-d trigger rate plot after cuts
#pql   *pm	h/plot 20 BOX
#pql   *pm	atitle ' X "M#degrees"N# (after cuts)' 'Y "M#degrees"N#'
#pql *
#pql * switch Z
#pql * pic/cr MERGE2
#pql *** Delta-t distribution
#pql opt logy
#pql *pm	h/pl 50 ; set dmod 1 k
#pql *pm	h/pl 50 pes 50
#pql opt linx ; opt liny
#pql *pm	atitle '[D]t "M#sec"N#' 'Events per Bin'
#pql * pic/cr MERGE1
#pql *** Delta-t distribution
#pql * zone 3 5 1 s
#pql opt logy
#pql * h/pl 55
#pql *pm	h/pl 55 ; set dmod 1 k
#pql *pm	h/pl 55 pes 55
#pql opt linx ; opt liny
#pql *pm	atitle '[D]t "M#sec"N#' 'Events per Bin'
#pql * izpic MERGE2 C
#pql * switch G
#pql * zone 3 5 1 s
#pql * xinset=($HINFO(50,'XMIN')+$HINFO(50,'XMAX'))/2.
#pql * yinset=($HINFO(50,'MAX')+$HINFO(50,'MIN'))/2.
#pql * message 'xinset = '//[xinset]//' yinset = '//[yinset]
#pql * pi/merge MERGE1 [xinset] [yinset] 0.5 D
#pql * zone 3 5 1 s
#pql * pi/merge MERGE1 0.085 0.445 0.5 
#pql * zone 3 5 1 s
#pql * pict/plot MERGE2
#pql * pi/del MERGE1
#pql * pi/del MERGE2
#pql *
#pql * zone 3 5 2 s
#pql *** Delta-t distribution
#pql * opt logy
#pql * h/pl 50 ; set dmod 1 k
#pql * h/pl 50 pes 50
#pql * opt linx ; opt liny
#pql * atitle '[D]t "M#sec"N#' 'Events per Bin'
#pql *** Delta-t distribution
#pql * zone 4 8 5 s
#pql * opt logy
#pql * h/pl 55 ; set dmod 1 k
#pql * h/pl 55 pes 55
#pql * opt linx ; opt liny
#pql * atitle '[D]t "M#sec"N#' 'Events per Bin'
#pql * zone 3 6 2 s
#pql *
#pql *** Events per minute vs. time
#pql   h/pl 25 ; set dmod 1 k
#pql   h/pl 25 pes 25
#pql   atitle 'UTC Time "M#sec"N#' 'Events per Minute'
#pql   ymax1=$HINFO(25,'MAX')
#pql   ymax2=$HINFO(30,'MAX')
#pql   h/get/cont 30 hva
#pql   if [ymax2].gt.0.0001 then
#pql      scalef=0.75*[ymax1]/[ymax2]
#pql   else
#pql      scalef=1.
#pql   endif
#pql   scalef=$format([scalef],f5.0)
#pql   vec/op/vscale hva [scalef] hvb
#pql   * h/del 30
#pql   * hi/create/1dhisto 30 ' ' 35 0. 2100.
#pql   h/put/cont 30 hvb
#pql   set DMOD 3
#pql   * set HTYP -3
#pql   h/pl 30 s 
#pql   set DMOD 0
#pql   * set HTYP -0
#pql ENDIF
#pql *
#pql *** PMTs in images passing cuts
#pql *pm	hi/plot 40
#pql *pm	atitle 'No. PMTs in Picture'
#pql *
#pql *** Length
#pql hi/plot 61
#pql atitle 'LENGTH "M#degrees"N#' 'events/bin'
#pql ymax1=$HINFO(61,'MAX')
#pql ymax2=$HINFO(62,'MAX')
#pql * message 'ymax1 = '//[ymax1]
#pql * message 'ymax2 = '//[ymax2]
#pql h/get/cont 62 hva
#pql if [ymax2].gt.0.0001 then
#pql    scalef=0.75*[ymax1]/[ymax2]
#pql else
#pql    scalef=1.
#pql endif
#pql scalef=$format([scalef],f5.0)
#pql ytext=0.6*[ymax1]
#pql xtext=1.2*$HINFO(62,'MEAN')
#pql text [xtext] [ytext] '"x#'//[scalef] 0.2 ! l
#pql * message 'scalef = '//[scalef]
#pql vec/op/vscale hva [scalef] hvb
#pql h/put/cont 60 hvb
#pql set DMOD 3
#pql * set HTYP -3
#pql * set HTYP 357
#pql h/pl 60 s 
#pql set DMOD 0
#pql * set HTYP -0
#pql * kuip/wait 'pausing for 4 sec' 4
#pql *
#pql *** Width
#pql hi/plot 63
#pql atitle 'WIDTH "M#degrees"N#' 'events/bin'
#pql * Get number of 0 width events for estimate of noise triggers
#pql h/get/cont 63 hva
#pql v/cr noise(1)
#pql v/cr ntot(1)
#pql v/input noise $eval(hva(1))
#pql sigma ntot=vsum(hva)
#pql sigma noise=noise/ntot
#pql noise=$format($eval(noise),f5.3)
#pql * multiply accepted events by a factor to make them visible in the 
#pql * raw distribution
#pql ymax1=$HINFO(63,'MAX')
#pql ymax2=$HINFO(64,'MAX')
#pql text 0.95 [ymax1] 'Noise fr.='//[noise] 0.3 ! R
#pql h/get/cont 64 hva
#pql if [ymax2].gt.0.0001 then
#pql    scalef=0.75*[ymax1]/[ymax2]
#pql else
#pql    scalef=1.
#pql endif
#pql scalef=$format([scalef],f5.0)
#pql ytext=0.6*[ymax1]
#pql xtext=1.4*$HINFO(64,'MEAN')
#pql text [xtext] [ytext] '"x#'//[scalef] 0.2 ! l
#pql vec/op/vscale hva [scalef] hvb
#pql h/put/cont 64 hvb
#pql * set HTYP 357
#pql set DMOD 3
#pql * set HTYP -3
#pql h/pl 64 s 
#pql set DMOD 0
#pql * set HTYP -0
#pql * hi/plot 64
#pql * atitle 'width "M#degrees"N# (after cuts)' 'events/bin'
#pql *
#pql *** Dist
#pql *pm	hi/plot 65
#pql *pm	atitle 'DISTANCE "M#degrees"N#' 'events/bin'
#pql *pm	ymax1=$HINFO(65,'MAX')
#pql *pm	ymax2=$HINFO(66,'MAX')
#pql *pm	h/get/cont 66 hva
#pql *pm	if [ymax2].gt.0.0001 then
#pql *pm	   scalef=0.75*[ymax1]/[ymax2]
#pql *pm	else
#pql *pm	   scalef=1.
#pql *pm	endif
#pql *pm	scalef=$format([scalef],f5.0)
#pql *pm	ytext=0.6*[ymax1]
#pql *pm	xtext=1.4*$HINFO(66,'MEAN')
#pql *pm	text [xtext] [ytext] '"x#'//[scalef] 0.2 ! l
#pql *pm	vec/op/vscale hva [scalef] hvb
#pql * h/del 66
#pql *pm	h/put/cont 66 hvb
#pql * set HTYP 357
#pql *pm	set DMOD 3
#pql * set HTYP -3
#pql *pm	h/pl 66 s 
#pql *pm	set DMOD 0
#pql * set HTYP -0
#pql * hi/plot 66
#pql * atitle 'distance "M#degrees"N# (after cuts)' 'events/bin'
#pql *
#pql *** Size
#pql *pm	ymax1=$HINFO(67,'MAX')
#pql *pm	ymax2=$HINFO(68,'MAX')
#pql *pm	opt logx; opt logy       | log-scale
#pql *pm	h/pl 67 ; set dmod 1 k
#pql *pm	h/pl 67 pes 67
#pql *pm	h/get/cont 68 hva
#pql *pm	if [ymax2].gt.0.0001 then
#pql *pm	   scalef=0.20*[ymax1]/[ymax2]
#pql *pm	else
#pql *pm	   scalef=1.
#pql *pm	endif
#pql *pm	scalef=$format([scalef],f5.0)
#pql *pm	ytext=0.10*[ymax1]
#pql *pm	xtext=1.3*$HINFO(68,'MEAN')
#pql *pm	text [xtext] [ytext] '"x#'//[scalef] 0.2 ! l
#pql *pm	vec/op/vscale hva [scalef] hvb
#pql * h/del 68
#pql *pm	h/put/cont 68 hvb
#pql * set HTYP 357
#pql *pm	set DMOD 3
#pql * set HTYP -3
#pql *pm	h/pl 68 s 
#pql *pm	set DMOD 0
#pql * set HTYP -0
#pql *pm	atitle 'SIZE "M#d.c."N#' 'Events/Bin'
#pql *pm	opt linx; opt liny
#pql *
#pql *** Size
#pql * opt logx; opt logy
#pql * h/pl 67 ; set dmod 1 k
#pql * h/pl 67 pes 67
#pql * atitle 'total signal "M#d.c."N# (after cuts)' 'events/bin'
#pql opt linx; opt liny
#pql *
#pql *** Hadronicity
#pql * opt logy
#pql * hi/plot 70
#pql * atitle 'HADRONICITY '  'Events/Bin'
#pql * ymax1=$HINFO(70,'MAX')
#pql * ymax2=$HINFO(75,'MAX')
#pql * h/get/cont 75 hva
#pql * if [ymax2].gt.0.0001 then
#pql *    scalef=0.20*[ymax1]/[ymax2]
#pql * else
#pql *    scalef=1.
#pql * endif
#pql * vec/op/vscale hva [scalef] hvb
#pql * h/put/cont 75 hvb
#pql * set HTYP -3
#pql * h/pl 75 s 
#pql * set HTYP -0
#pql * opt liny
#pql *
#pql *** Hadronicity (supercuts)
#pql * opt logy
#pql * hi/plot 75
#pql * atitle 'hadronicity (after cuts)'  'events/bin'
#pql * opt liny
#pql *
#pql *** Gain
#pql *pm	ymax1=$HINFO(80,'MAX')
#pql *pm	ymax2=$HINFO(82,'MAX')
#pql IF [ymax1] > 0 THEN
#pql *  opt logx
#pql *  hi/plot 80
#pql *  atitle 'MUON GAIN'  'Events/Bin'
#pql *  h/get/cont 82 hva
#pql *  if [ymax].gt.0.0001 then
#pql *     scalef=0.75*[ymax1]/[ymax2]
#pql *  else
#pql *     scalef=1.
#pql *  endif
#pql *  vec/op/vscale hva [scalef] hvb
#pql *  h/put/cont 82 hvb
#pql *  set HTYP -3
#pql *  h/pl 82 s
#pql *  set HTYP -0
#pql *  ymax2=$HINFO(85,'MAX')
#pql *  h/get/cont 85 hva
#pql *  if [ymax2].gt.0.0001 then
#pql *     scalef=0.75*[ymax1]/[ymax2]
#pql *  else
#pql *     scalef=1.
#pql *  endif
#pql *  vec/op/vscale hva [scalef] hvb
#pql *  hi/create/1dhisto 86 ' ' 20 0. 100.0
#pql *  h/put/cont 86 hvb
#pql *  set HTYP -3
#pql *  hi/plot 86 s
#pql *  set HTYP -0
#pql *  opt linx
#pql *** Gain after hadronicity cut
#pql *  h/pl 85 s ; set dmod 1 k
#pql * opt fit
#pql * hi/fit 85 G
#pql *pm	  set dmod 1 k
#pql *pm	  h/pl 85 pes 85
#pql *pm	  atitle 'MUON GAIN'  'Events/Bin'
#pql *pm	  opt nfit
#pql *ELSE      | If muon gain not calculated, print out totsig/length
#pql *  null 0 16 0 16 AB
#pql ENDIF
#pql *** Length/size
#pql ymax1=$HINFO(86,'MAX')
#pql ymax2=$HINFO(87,'MAX')
#pql * opt logx
#pql hi/plot 86
#pql atitle 'LENGTH/SIZE'  'Events/Bin'
#pql * Get fraction of events with l/s .gt. 0.001 for estimate of muons.
#pql h/get/cont 86 hva
#pql v/cr muons(1)
#pql sigma hva=sumv(hva)
#pql v/input muons $eval(hva(20))
#pql v/input ntot $eval(hva(40))
#pql sigma muons=ntot-muons
#pql sigma muons=muons/ntot
#pql muons=$format($eval(muons),f5.3)
#pql text 0.0019 [ymax1] 'Mu fr.='//[muons] 0.3 ! R
#pql * Multiply cut events by a factor to make it visible
#pql h/get/cont 87 hva
#pql if [ymax2].gt.0.0001 then
#pql    scalef=0.75*[ymax1]/[ymax2]
#pql else
#pql    scalef=1.
#pql endif
#pql scalef=$format([scalef],f5.0)

#pql ytext=0.6*[ymax1]
#pql xtext=1.4*$HINFO(87,'MEAN')
#pql text [xtext] [ytext] '"x#'//[scalef] 0.3 ! l

#pql vec/op/vscale hva [scalef] hvb
#pql h/put/cont 87 hvb
#pql set DMOD 2
#pql * set HTYP -3
#pql h/pl 87 s
#pql set DMOD 0
#pql * set HTYP -0
#pql * atitle 'gain (after cuts)'  'events/bin'
#pql ymax2=$HINFO(88,'MAX')
#pql h/get/cont 88 hva
#pql if [ymax2].gt.0.0001 then
#pql    scalef=0.75*[ymax1]/[ymax2]
#pql else
#pql    scalef=1.
#pql endif
#pql scalef=$format([scalef],f5.0)
#pql vec/op/vscale hva [scalef] hvb
#pql * hi/create/1dhisto 88 ' ' 20 0. 100.0
#pql h/put/cont 88 hvb
#pql set DMOD 3
#pql * set HTYP -3
#pql hi/plot 88 s
#pql set DMOD 0
#pql * set HTYP -0
#pql opt linx
#pql *
#pql *** Muon veto - 971117 MAC no longer exists.
#pql *opt logx
#pql *opt logy
#pql *hi/plot 89
#pql *atitle 'Anticoin. Pulseheight' ' '
#pql *opt linx
#pql *opt liny
#pql *
#pql *** Neighbor trigger
#pql *pm	opt logy
#pql *pm	hi/plot 90 
#pql *pm	atitle 'Num. Adj. Triggering Tubes'  'events/bin'
#pql * Estimate noise fraction
#pql *pm	v/cr pts(4)
#pql *pm	h/get/cont 90 pts
#pql *pm	sigma pts=sumv(pts)
#pql *pm	v/inp noise $eval(pts(2))
#pql *pm	v/inp ntot $eval(pts(4))
#pql *pm	sigma noise=noise/ntot
#pql *pm	noise=$format($eval(noise),f5.3)
#pql * Multiply accepted events by a factor to make them visible
#pql *pm	ymax1=$HINFO(90,'MAX')
#pql *pm	ymax2=$HINFO(95,'MAX')
#pql *pm	ytext=[ymax1]+0.1*[ymax1]
#pql *pm	text 0.75 [ytext] 'Noise fr='//[noise] 0.3 ! l
#pql *pm	h/get/cont 95 hva
#pql *pm	if [ymax2].gt.0.0001 then
#pql *pm	   scalef=0.20*[ymax1]/[ymax2]
#pql *pm	else
#pql *pm	   scalef=1.
#pql *pm	endif
#pql *pm	scalef=$format([scalef],f5.0)
#pql *pm	ytext=0.15*[ymax1]
#pql *pm	xtext=0.8*$HINFO(95,'MEAN')
#pql *pm	text [xtext] [ytext] '"x#'//[scalef] 0.2 ! r
#pql *pm	vec/op/vscale hva [scalef] hvb
#pql *pm	h/put/cont 95 hvb
#pql *pm	set DMOD 3
#pql * set HTYP -3
#pql *pm	hi/plot 95 s
#pql *pm	set DMOD 0
#pql * set HTYP -0
#pql * atitle 'Num. Adj. Triggering Tubes (after cuts)'  'events/bin'
#pql *** Asymmetry
#pql *pm	opt logy
#pql *pm	hi/plot 91
#pql *pm	atitle 'Asymmetry'  'events/bin'
#pql *pm	ymax1=$HINFO(91,'MAX')
#pql *pm	ymax2=$HINFO(92,'MAX')
#pql *pm	h/get/cont 92 hva
#pql *pm	if [ymax2].gt.0.0001 then
#pql *pm	   scalef=0.20*[ymax1]/[ymax2]
#pql *pm	else
#pql *pm	   scalef=1.
#pql *pm	endif
#pql *pm	scalef=$format([scalef],f5.0)
#pql *pm	ytext=0.15*[ymax1]
#pql *pm	xtext=0.8*$HINFO(92,'MEAN')
#pql *pm	text [xtext] [ytext] '"x#'//[scalef] 0.2 ! r
#pql *pm	vec/op/vscale hva [scalef] hvb
#pql *pm	h/put/cont 92 hvb
#pql *pm	set DMOD 3
#pql *pm	hi/plot 92 s
#pql *pm	set DMOD 0
#pql *pm	opt liny
#pql *
#pql /picture/print [1]_ql.ps
#pql pict/delete QLPLOT
#pql switch G
#pql *pm	kuip/wait 'pausing for 10 sec' 10
#pql *
#pql * pict/create QLPLOT
#pql * set VSIZ 0
#pql * zone 2 3 1
#pql * h/get/cont 17 trig
#pql * exec quicklook#whipcam trig
#pql * atitle 'Times in Trigger  X "M#degrees"N# (after cuts)' 'Y "M#degrees"N#'
#pql * exec quicklook#whipcam ped
#pql * atitle 'Pedestals   XM#deg"N#'  ' YM#deg"N#'
#pql * exec quicklook#whipcam pedvar
#pql * atitle 'Pedestal Variances   XM#deg"N#'  ' YM#deg"N#'
#pql * exec quicklook#whipcam xr yr dped
#pql * atitle 'Stars   XM#deg"N#'  ' YM#deg"N#'
#pql * exec quicklook#whipcam gain
#pql * atitle 'Nitrogen Gains   XM#deg"N#'  ' YM#deg"N#'
#pql *** 2-d
#pql * contour 99 10 2
#pql * atitle ' X "M#degrees"N# (after cuts)' 'Y "M#degrees"N#'
#pql * kuip/wait 'pausing for 4 sec' 4
#pql *
#pql * /picture/print [1]_pg.ps
#pql * pict/delete QLPLOT
#pql *
#pql * picture/delete *
#pql vec/del *
#pql h/delete 0
#pql close 0
#pql return
#pql 
#pql *************************************************************
#pql *
#pql MACRO whipcam 
#pql *  
#pql *
#pql *  Usage: exec quicklook#whipcam [x y] [vec]
#pql *
#pql *  Set up a couple of things
#pql *
#pql dbdirw = '/usr/dbgt/'
#pql pfield = 2.7
#pql mfield = -2.7
#pql *
#pql *  Plot vector "vec" of values on the default x,y
#pql *  tube coordinates of the whipple camera, or those specified
#pql *  by the vectors "x" and "y"
#pql *
#pql vec/create x([ntb]) R 
#pql vec/create y([ntb]) R 
#pql  
#pql vec/read x,y [dbdirw]whip10m.coords
#pql graphics/attrib/sfais 1
#pql graphics/attrib/sfaci 10
#pql graphics/attrib/sfaci 6    
#pql * null -1.7 1.7 -1.7 1.7 
#pql null [mfield] [pfield] [mfield] [pfield]
#pql 
#pql if [#].eq.0 then
#pql   do i=1,[ntb]
#pql    graphics/primitives/arc x([i]) y([i]) 0.124 0.124
#pql    graphics/pr/text x([i]) y([i])-0.04 [i] .15 ! c 
#pql   enddo
#pql else
#pql   if [#].eq.3 then
#pql     vec/del x
#pql     vec/del y
#pql     vec/create x([ntb]) R 
#pql     vec/create y([ntb]) R 
#pql     vec/copy [1] x
#pql     vec/copy [2] y
#pql     vec/copy [3] adc
#pql     message 'Using x,y vectors from command line'
#pql   else
#pql     vec/copy  [1] adc
#pql   endif
#pql   vec/cre adcor([ntb]) r
#pql   vec/copy adc adcor
#pql   sigma dmax=vmax(adc)
#pql   tempd = $eval(dmax(1))
#pql   IF [tempd].lt.1.0 THEN
#pql     tempd = 1.0
#pql   ENDIF
#pql   vec/op/vscale adc (0.124/[tempd]) adc
#pql   do i=1,[ntb]
#pql       graphics/primitives/arc x([i]) y([i]) 0 adc([i])     
#pql       graphics/primitives/arc x([i]) y([i]) 0.124 0.124
#pql *     graphics/pr/text x([i]) y([i])-0.04 [i] .15 ! c      
#pql   enddo
#pql   tdmax=dmax(1)
#pql   txt='0 to '//[tdmax]
#pql   graphics/pr/text 1.0 -1.5  [txt] .25 ! c 
#pql endif
#pql 
#pql return
#pql 
#------------------------------------------------------------------------------
#pdg *
#pdg * diagnostic.kumac
#pdg * MAC
#pdg * 980929
#pdg *
#pdg * PAW kumac to generate read in diagnostic histogram file created by fz2red
#pdg * Only does one file at a time, just as with quicklook.kumac.  
#pdg *
#pdg * Usage exec diagnostic gt4643
#pdg *
#pdg * 000228 MAC Added in Stephane LeBohec's relative gain calculation to the kumac
#pdg *
#pdg * Define options
#pdg *
#pdg *
#pdg opt nbox             | no box around plot
#pdg opt a4
#pdg opt linx
#pdg opt liny
#pdg set mtyp 1           | marker type
#pdg set xlab 1.2         | dist label to y-axis (default = 1.4)
#pdg set ylab 0.6         | dist label to x-axis (default = 1.4)
#pdg set xwin 1.7         | x-dist between plots (default = 2.0)
#pdg set ywin 1.4         | y-dist between plots (default = 2.0)
#pdg set asiz 0.22        | axis label size (default = 0.28)
#pdg set xval 0.2         | x-dist to y bins (default = 0.4)
#pdg set XMGL 2.0         | Margins (defualt = 2.0)     
#pdg set XMGR 1.0
#pdg set YMGL 1.5
#pdg set YMGU 2.1
#pdg set VSIZ 0.18
#pdg set pmci 1
#pdg set plci 1
#pdg set txci 1
#pdg set hcol 1
#pdg set vfon -80
#pdg set lfon -80
#pdg opt ngri
#pdg igset mtyp 1.
#pdg comisdir='/usr/local/whipple/src/vpro/alphatot2/'   | Home dir. for sel.funcs
#pdg dbdir='/usr/dbgt/'                                  | Data base dir.
#pdg *------------------------------------------------------------------------
#pdg fname=[1]
#pdg h/file 1 [fname]_d.hbook
#pdg opt utit
#pdg title 'Quicklook "J#'//[fname]//' '//$DATE
#pdg set asiz 0.3
#pdg igset mscf 0.3
#pdg pic/create PLOT1
#pdg zone 4 4
#pdg *
#pdg * Tracking records plots
#pdg *
#pdg h/plot 1
#pdg atitle 'Track dev. (deg)' 'No. records'
#pdg igset mtyp 20
#pdg h/plot 2 p
#pdg atitle 'Time (min)' 'El (deg)'
#pdg h/plot 3 p
#pdg atitle 'Time (min)' 'Az (deg)'
#pdg * Don't plot these, the variables are never filled.
#pdg *old h/plot 4 p
*old atitle 'Time of run (min)' 'R.A. (deg)'
*old h/plot 5 p
*old atitle 'Time of run (min)' 'Dec. (deg)'
#pdg *
#pdg * Time plots
#pdg *
#pdg opt logy
#pdg h/plot 11
#pdg opt liny
#pdg atitle 'GPS-scaler (ms)'
#pdg null -4. 4. 0. 10. ABS
#pdg set dmod 2
#pdg gr/pr/line 0. 0. 0. 10.
#pdg set dmod 1
#pdg h/plot 12 p
#pdg igset mtyp 1
#pdg atitle 'Time of run (min)' 'GPS-scaler (ms)'
#pdg v/cr ptot(1)
#pdg v/cr pts(1000)
#pdg h/get_vec/cont 13 pts
#pdg sigma ptot=vsum(pts)
#pdg xmax=$eval(ptot(1))
#pdg if [xmax].gt.0. then
#pdg  opt logy
#pdg else
#pdg  opt liny
#pdg endif
#pdg h/plot 13
#pdg atitle 'Osc [n]-1.e7 (Hz)'
#pdg *
#pdg * Trigger plots
#pdg *
#pdg zone 2 4 4 s
#pdg h/get_vec/cont 21 pts
#pdg sigma ptot=vsum(pts)
#pdg xmax=$eval(ptot(1))
#pdg if [xmax].gt.0. then
#pdg  opt logy
#pdg else
#pdg  opt liny
#pdg endif
#pdg h/plot 21
#pdg opt liny
#pdg atitle 'Trigger bits' 'Events when set'
#pdg igset chhe 0.25
#pdg igset tang 90.
#pdg igset txal 30
#pdg null -0.5 9.5 0. 10. ABS
#pdg itx 0.25 9.6 'Ped'
#pdg itx 1.25 9.6 'PST'
#pdg itx 2.25 9.6 'Trg'
#pdg itx 3.25 9.6 'Ped+PST'
#pdg itx 4.25 9.6 'Ped+Trg'
#pdg itx 5.25 9.6 'PST+Trg'
#pdg itx 6.25 9.6 'Ped+PST+Trg'
#pdg itx 7.25 9.6 'PST, No Trg'
#pdg itx 8.25 9.6 'Trg, No PST'
#pdg itx 9.25 9.6 'Nothing'
#pdg *
#pdg * HV plots
#pdg *
#pdg zone 3 4 7 s
#pdg igset mtyp 20.
#pdg set ksiz 0.03
#pdg h/plot 31
#pdg igset mtyp 1.
#pdg set ksiz 0.28
#pdg atitle 'PMT' 'HV (V)'
#pdg h/plot 32
#pdg atitle 'PMT' 'Anode current ([u]A)'
#pdg *
#pdg * Singles rate plots.
#pdg *
#pdg h/plot 41
#pdg atitle 'PMT' 'Singles rate (Hz)'
#pdg h/del 0
#pdg close 1
#pdg ***************************************************************************
#pdg * Relative gain calculation that Stephane LeBohec developed.
#pdg * NOTE: The numbers generated are only relevant for zenith files.
#pdg ***************************************************************************
#pdg ve/cr zen r
#pdg ve/read zen zen.dat
#pdg * Only compute relative gain if this IS a zenith run
#pdg if zen.eq.1 then
#pdg   zone 2 4 7 s
#pdg   opt liny
#pdg   opt logx
#pdg   opt tic
#pdg   opt grid
#pdg   *opt utitl
#pdg   set pass 3
#pdg   set vfon -10
#pdg 
#pdg   opt nbox
#pdg 
#pdg   ali/cr binnb 40               |No. of bins in histogram
#pdg   ali/cr p2max 600.0            |Upper bound of histogram
#pdg   ali/cr p2min 20.0             |Lower bound of histogram
#pdg   ali/cr nbpoints 31            |Num points in gain fit
#pdg   ali/cr gainmin 0.5            |Min. gain normalization
#pdg   ali/cr gainstep 0.05          |Gain step sizes
#pdg   ali/cr npfit 17               |No. of bins to use in chi2 min fit.
#pdg   ali/cr weigh 1.00
#pdg   ali/cr varr t10max3           |Ntuple name for max3
#pdg   ali/cr timeref t10livetime    |Ntuple name for livetime
#pdg   ali/cr ntplid 100             |Ntuple ID
#pdg 
#pdg   ve/cr gain(nbpoints) R
#pdg   ve/cr vchi(nbpoints) R
#pdg   ve/cr tdur(1) R
#pdg 
#pdg   * Open the reference distribution histogram file
#pdg   hi/file 2 [dbdir]ref_zen_gain.hbook
#pdg   ve/cr val1(binnb) R
#pdg   hi/get_vect/content 1 val1
#pdg 
#pdg   * Identify the location of the maximum of the distribution
#pdg   sigma imax1=lvmax(val1)
#pdg 
#pdg   * Open the current ntuple
#pdg   hi/file 1 [1].rz
#pdg   * Get the duration of the run for normalisation
#pdg   nt/loop ntplid [comisdir]duration.f
#pdg   sigma tdur=1/tdur
#pdg 
#pdg   *-----------------------------------------------------------------------
#pdg   * Here comes the relative gain calibration.
#pdg   *-----------------------------------------------------------------------
#pdg   do j=1,nbpoints
#pdg      h/cr/1d 2 'Calibrate' binnb p2min p2max 
#pdg 
#pdg   * Pick a relative gain and normalize the bin contents by that value.
#pdg     vect/input gain([j]:[j]) $sigma(([j]-1)*(gainstep)+(gainmin)) 
#pdg     nt/proj 2  ntplid.((varr)/$sigma(gain([j]))) (weigh)
#pdg 
#pdg   * Renormalize the duration.
#pdg     hi/op/add 2 2 2 $sigma(tdur) 0. E
#pdg 
#pdg   * Compare the count rates of the reference file to the current file
#pdg   * for the assumed gain.
#pdg     h/cr/1d 3 'Difference' binnb p2min p2max
#pdg     hi/op/sub 1 2 3 1.0 1.0 E
#pdg 
#pdg   * Feed vector with contents and errors of 3
#pdg     ve/cr val(binnb) R
#pdg     ve/cr err(binnb) R
#pdg     ve/cr chi2(binnb) R
#pdg     hi/get_vect/content 3 val
#pdg     hi/get_vect/error   3 err
#pdg 
#pdg   * Compute the chi2 terms=((val/err)^2)
#pdg     vector/operation/vdivide val err chi2
#pdg     vector/operation/vmultiply chi2 chi2 chi2 
#pdg 
#pdg   * Seeks for the max of histo 2
#pdg     ve/cr val2(binnb) R
#pdg     hi/get_vect/content 2 val2
#pdg     sigma imax2=lvmax(val2)
#pdg   * vect/print imax2
#pdg 	
#pdg   * Identifies the rightmost maximum bin of the two
#pdg     if imax1.gt.imax2 then
#pdg       sigma itop=imax1
#pdg     else 
#pdg       sigma itop=imax2
#pdg     endif
#pdg   * vect/print itop
#pdg 
#pdg   * Computes the chi2 as the sum of terms starting 
#pdg   * 2 bins above the rightmost maximum
#pdg     sigma optim=0
#pdg     do i=itop+2,(binnb) 
#pdg       sigma optim=optim+chi2([i])
#pdg     enddo
#pdg   * Chi2 per dof
#pdg     sigma optim=optim/((binnb)-(itop+1))
#pdg   * ve/print gain([j])
#pdg     vect/input vchi([j]:[j]) $sigma(optim) 
#pdg   * ve/print vchi([j])
#pdg 
#pdg 
#pdg     ve/del val 
#pdg     ve/del val2 
#pdg     ve/del err 
#pdg     ve/del chi2
#pdg     hi/del 2
#pdg     hi/del 3
#pdg   enddo
#pdg 
#pdg   * Find the npfit lowest chi2 values to use for a fit to get the best
#pdg   * gain factor.
#pdg   ve/cr minchi(npfit) 
#pdg   do i=1,(npfit)
#pdg     ve/inp minchi([i]) 1.
#pdg   enddo
#pdg   do i=1,(npfit)
#pdg     do j=2,(nbpoints)
#pdg       if vchi([j]).lt.vchi(minchi([i])) then
#pdg         sigma tst=1
#pdg         do k=1,npfit
#pdg           if [j].eq.minchi([k]) then
#pdg             sigma tst=0
#pdg 	       endif
#pdg         enddo
#pdg         if tst.eq.1 then
#pdg           ve/inp minchi([i]) [j]
#pdg         endif
#pdg       endif
#pdg     enddo
#pdg   enddo
#pdg 
#pdg   * Create the vectors to be fitted and fill them
#pdg   ve/cr vxf(npfit)
#pdg   ve/cr vyf(npfit)
#pdg   ve/cr vef(npfit)
#pdg   do i=1,npfit
#pdg     ve/input vxf([i]) $sigma(gain(minchi([i])))
#pdg     ve/input vyf([i]) $sigma(vchi(minchi([i])))
#pdg   enddo
#pdg 
#pdg   sigma vef=vyf
#pdg 
#pdg   * Fit the chi2 data to find the minimum and the corresponding 
#pdg   ve/cr par(3) R
#pdg   ve/fit vxf vyf vef [comisdir]gain_fit.for 'N' 3 par
#pdg 
#pdg   * Now plot up the results of the fits, etc.
#pdg   opt linx
#pdg   opt liny
#pdg   *old zone 1 2
#pdg   *old fortran/file 66 gainfig1.ps
#pdg   *old meta 66 -113
#pdg   nul gainmin $sigma((nbpoints)*(gainstep)+(gainmin)) 0. 10.
#pdg   * Plot the chi2 points distribution and the fit result.
#pdg   GRAPHICS/HPLOT/SYMBOLS gain vchi nbpoints 24
#pdg   fun/plot [comisdir]gain_fit.for gainmin (gainmin)+(nbpoints)*(gainstep) s
#pdg   atitl 'Relative Gain Value' '[h]^2!/n'
#pdg 
#pdg   v/cr rgain(1) r
#pdg   sigma rgain=exp(par(3))
#pdg   *old text 0.9 8.8  'Zenith run = '//[1] 0.4
#pdg   *old text 0.9 7.8  'Gain = '//$sigma(exp(par(3))) 0.4
#pdg   text 0.8 8.8  'Gain = '//$format($eval(rgain),f5.3) 0.4
#pdg   *text 0.9 7.8  'Gain = '//$sigma(sqrt(par(2)/par(3))) 0.4
#pdg   *text 0.9 7.8  'Gain = '//$sigma(1+par(3)) 0.4
#pdg   *old text 0.9 6.8 'Reference run = '//$HTITLE(1) 0.4
#pdg   text 0.8 7.8 'Ref. run = '//$HTITLE(1) 0.4
#pdg 
#pdg   * Now plot the two max3 distributions for the runs.
#pdg   *set pmci 4
#pdg   *set plci 3
#pdg   set txci 1
#pdg   opt logy
#pdg   opt logx
#pdg   cd //lun2
#pdg   *old set hcol 4
#pdg   igset mtyp 1.
#pdg   h/plot 1
#pdg   cd //lun1
#pdg   h/cr/1d 2 'Calibrate' binnb p2min p2max 
#pdg   nt/proj 2  ntplid.(varr) (weigh)
#pdg   hi/op/add 2 2 2 $sigma(tdur) 0. E
#pdg   *old set hcol 2
#pdg   *set dmod 2
#pdg   igset mtyp 31.
#pdg   h/plot 2 s
#pdg   *set dmod 1
#pdg   atitl 'max3' 'Event rate per bin (Hz)'
#pdg 
#pdg   opt linx
#pdg   opt liny
#pdg   null 0. 10. 0. 10. abs
#pdg   v/cr x(1) r 9.0
#pdg   v/cr y(1) r 8.8
#pdg   *gr/hp/symb 9.5 9.5 1 1
#pdg   gr/hp/symb x y 1 31 0.35
#pdg   text 5.8 8.5 'This run'  0.4
#pdg   *gr/hp/key 5. 9.5 31 'This run'
#pdg   *old close 66
#pdg endif
#pdg close 1
#pdg close 2
#pdg 
#pdg * Clean up the fiddly bits.
#pdg ve/del GAIN
#pdg ve/del VCHI
#pdg ve/del VAL1
#pdg ve/del TDUR
#pdg ve/del x
#pdg ve/del y
#pdg ve/del rgain
#pdg ve/del ptot
#pdg ve/del minchi
#pdg ve/del pts
#pdg ve/del vxf
#pdg ve/del vyf
#pdg ve/del vef
#pdg ve/del par
#pdg ve/del zen
#pdg 
#pdg hi/del 2
#pdg hi/del 1
#pdg 
#pdg *
#pdg * Now print out the plot.
#pdg *
#pdg kuip/wait 'Pausing for 5 seconds' 5
#pdg pic/print [fname]_dg.ps
#pdg pic/del PLOT1
#pdg 
#pdg opt htit
#pdg set asiz 0.22
#pdg igset mscf 1.0
#pdg opt ngri
#pdg opt ntic
#pdg set lfon 02
#pdg set vfon 02
#pdg set txfp 10.
#pdg *
#pdg * Done
#pdg *
#pdg return

#pdog *
#pdog * diagnostic.kumac
#pdog * MAC
#pdog * 980929
#pdog *
#pdog * PAW kumac to generate read in diagnostic histogram file created by fz2red
#pdog * Only does one file at a time, just as with quicklook.kumac.  
#pdog *
#pdog * Define options
#pdog *
#pdog *
#pdog opt nbox             | no box around plot
#pdog opt a4
#pdog opt linx
#pdog opt liny
#pdog set mtyp 1           | marker type
#pdog set xlab 1.3         | dist label to y-axis (default = 1.4)
#pdog set ylab 0.6         | dist label to x-axis (default = 1.4)
#pdog set xwin 1.9         | x-dist between plots (default = 2.0)
#pdog set ywin 1.4         | y-dist between plots (default = 2.0)
#pdog set asiz 0.22        | axis label size (default = 0.28)
#pdog set XMGL 2.0         | Margins (defualt = 2.0)     
#pdog set XMGR 1.0
#pdog set YMGL 1.5
#pdog set YMGU 2.1
#pdog set VSIZ 0.18
#pdog *------------------------------------------------------------------------------
#pdog fname=[1]
#pdog h/file 1 [fname]_d.hbook
#pdog opt utit
#pdog title 'Quicklook "J#'//[fname]//' '//$DATE
#pdog set asiz 0.3
#pdog igset mscf 0.3
#pdog pic/create PLOT1
#pdog zone 3 4
#pdog *
#pdog * Tracking records plots
#pdog *
#pdog h/plot 1
#pdog atitle 'Tracking dev. (deg)' 'No. records'
#pdog igset mtyp 20
#pdog h/plot 2 p
#pdog atitle 'Time of run (min)' 'El (deg)'
#pdog h/plot 3 p
#pdog atitle 'Time of run (min)' 'Az (deg)'
#pdog h/plot 4 p
#pdog atitle 'Time of run (min)' 'R.A. (deg)'
#pdog h/plot 5 p
#pdog atitle 'Time of run (min)' 'Dec. (deg)'
#pdog *
#pdog * Time plots
#pdog *
#pdog opt logy
#pdog h/plot 11
#pdog opt liny
#pdog atitle 'GPS - El scaler (ms)'
#pdog null -4. 4. 0. 10. ABS
#pdog set dmod 2
#pdog gr/pr/line 0. 0. 0. 10.
#pdog set dmod 1
#pdog h/plot 12 p
#pdog igset mtyp 1
#pdog atitle 'Time of run (min)' 'GPS-El scaler (ms)'
#pdog v/cr ptot(1)
#pdog v/cr pts(1000)
#pdog h/get_vec/cont 13 pts
#pdog sigma ptot=vsum(pts)
#pdog xmax=$eval(ptot(1))
#pdog if [xmax].gt.0. then
#pdog  opt logy
#pdog else
#pdog  opt liny
#pdog endif
#pdog h/plot 13
#pdog atitle 'Osc freq - 1.e7 (Hz)'
#pdog *
#pdog * Trigger plots
#pdog *
#pdog h/get_vec/cont 21 pts
#pdog sigma ptot=vsum(pts)
#pdog xmax=$eval(ptot(1))
#pdog if [xmax].gt.0. then
#pdog  opt logy
#pdog else
#pdog  opt liny
#pdog endif
#pdog h/plot 21
#pdog opt liny
#pdog atitle 'Trigger bits' 'Events when set'
#pdog igset chhe 0.25
#pdog igset tang 90.
#pdog igset txal 30
#pdog null -0.5 9.5 0. 10. ABS
#pdog itx 0.25 9.9 'Ped'
#pdog itx 1.25 9.9 'PST'
#pdog itx 2.25 9.9 'Trg'
#pdog itx 3.25 9.9 'Ped+PST'
#pdog itx 4.25 9.9 'Ped+Trg'
#pdog itx 5.25 9.9 'PST+Trg'
#pdog itx 6.25 9.9 'Ped+PST+Trg'
#pdog itx 7.25 9.9 'PST, No Trg'
#pdog itx 8.25 9.9 'Trg, No PST'
#pdog itx 9.25 9.9 'Nothing'
#pdog *
#pdog * HV plots
#pdog *
#pdog igset mtyp 20.
#pdog set ksiz 0.03
#pdog h/plot 31
#pdog igset mtyp 1.
#pdog set ksiz 0.28
#pdog atitle 'PMT' 'HV (V)'
#pdog h/plot 32
#pdog atitle 'PMT' 'Anode current ([u]A)'
#pdog *
#pdog * Singles rate plots.
#pdog *
#pdog h/plot 41
#pdog atitle 'PMT' 'Singles rate (Hz)'
#pdog kuip/wait 'Pausing for 5 seconds' 5
#pdog pic/print [fname]_dg.ps
#pdog pic/del PLOT1
#pdog h/del 0
#pdog opt htit
#pdog set asiz 0.22
#pdog igset mscf 1.0
#pdog *
#pdog * Done
#pdog *
#pdog return
#pdog 
